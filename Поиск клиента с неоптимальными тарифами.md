# Поиск клиента с неоптимальными тарифами

## Материалы: https://disk.yandex.ru/d/eLF2VzDfomFzBw

## Описание проекта

Телеком провайдер «Нупозвони» ищет бомбических аналитиков. 

Наши клиенты − колл-центры, мы хотим проанализировать наши тарифы, насколько они подходят нашим клиентам и насколько для наших клиентов будет выгодна смена тарифа.

Мы имеем данные, описывающие использование услуг «Нупозвони» - провайдера виртуальной телефонии. Его клиенты - колл-центры, которые:
- распределяют входящие вызовы на операторов;
- совершают исходящие вызовы силами операторов.

Также операторы могут делать внутренние вызовы - вызовы друг между другом внутри сети виртуальной телефонии.

**Задача:**

Найти клиентов, которые:
- Переплачивают на текущих тарифах;
- Сэкономят, если перейдут на более дорогой тариф.

**Цель:**

Минимизировать возможный ущерб для компании.

### Описание тарифов

Ежемесячная плата за тариф:
- **Тариф А** — 4000 ₽,
- **Тариф B** — 2000 ₽,
- **Тариф С** — 1000 ₽.

Дополнительная ежемесячная плата за каждого оператора:
- **Тариф А** — 50 ₽,
- **Тариф B** — 150 ₽,
- **Тариф С** — 300 ₽.

Исходящие звонки внутри сети, включённые в тариф:
- **Тариф А** — 2000 минут,
- **Тариф B** — 500 минут,
- **Тариф С** — нет.

Цена сверх лимита:
- **A** — 0.1 ₽/мин.,
- **B** — 0.15 ₽/мин.,
- **C** — 0.3 ₽/мин.

Исходящие звонки, кроме внутренних:
- **A** — 0.3 ₽/мин.,
- **B** — 0.5 ₽/мин.,
- **C** — 0.7 ₽/мин.

Входящие звонки — **бесплатны** на всех тарифах.

### Описание данных датасетов

Датасет: **/datasets/telecom_dataset.csv:**
- **user_id** — идентификатор клиента;
- **date** — дата статистики;
- **direction** — направление вызовов:
    - **out** — исходящий вызов;
    - **in** — входящий;
- **internal** — маркер внутренних и внешних вызовов;
- **operator_id** — идентификатор оператора;
- **is_missed_call** — маркер пропущенных вызовов;
- **calls_count** — количество звонков;
- **call_duration** — длительность звонка без учёта времени ожидания, сек.;
- **total_call_duration** — длительность звонка с учётом времени ожидания, сек.

Можем наблюдать, что данный датасет хранит общую информацию по звонкам.

Датасет: **/datasets/telecom_clients.csv:**
- **user_id** — идентификатор клиента;
- **tariff_plan** — тарифный план клиента;
- **date_start** — дата регистрации клиента в сервисе.

Ну а создатели данного датасета думали только о клиентах.

Доступ к датасетам из интернета можно получить по адресу:
https://code.s3.yandex.net/datasets/

## Изучение данных

### Загрузка данных (датасетов)

***Ну что ж. Как говорил Юрий Алексеевич: "Поехали...".***

Для загрузки датасетов нам необходимо воспользоваться библиотекой pandas.

Для начала загрузим её:


```python
import pandas as pd
```

Подцепим датасеты к переменным и начнём изучение выделенных нам данных.

Переменная для датасета '**telecom_dataset**':


```python
td = pd.read_csv('/datasets/telecom_dataset.csv')
```

Переменная для датасета '**telecom_clients**'


```python
tc = pd.read_csv('/datasets/telecom_clients.csv')
```

Изучим каждый датасет по очереди. Так проще ориентироваться между ними.

### Анализ датасета 'telecom_dataset'

Посмотрим на общую информацию о датасете:


```python
td.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 53902 entries, 0 to 53901
    Data columns (total 9 columns):
     #   Column               Non-Null Count  Dtype  
    ---  ------               --------------  -----  
     0   user_id              53902 non-null  int64  
     1   date                 53902 non-null  object 
     2   direction            53902 non-null  object 
     3   internal             53785 non-null  object 
     4   operator_id          45730 non-null  float64
     5   is_missed_call       53902 non-null  bool   
     6   calls_count          53902 non-null  int64  
     7   call_duration        53902 non-null  int64  
     8   total_call_duration  53902 non-null  int64  
    dtypes: bool(1), float64(1), int64(4), object(3)
    memory usage: 3.3+ MB


53 902 строки и 9 столбцов. Есть над чем поработать. Плюс к тому же явно прослеживаются пропуски в двух столбцах и как минимум 1 неверный тип.

Посмотрим на общее количество уникальных клиентов:


```python
td.user_id.nunique()
```




    307



Не густно. Видимо создатели датасета больше ориентировались на звонки. В принципе это хорошо. Чем больше данных о клиенте, тем точнее будет итоговый результат.

Посмотрим как выглядит таблица.


```python
td
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>user_id</th>
      <th>date</th>
      <th>direction</th>
      <th>internal</th>
      <th>operator_id</th>
      <th>is_missed_call</th>
      <th>calls_count</th>
      <th>call_duration</th>
      <th>total_call_duration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>2019-08-04 00:00:00+03:00</td>
      <td>in</td>
      <td>False</td>
      <td>NaN</td>
      <td>True</td>
      <td>2</td>
      <td>0</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166377</td>
      <td>2019-08-05 00:00:00+03:00</td>
      <td>out</td>
      <td>True</td>
      <td>880022.0</td>
      <td>True</td>
      <td>3</td>
      <td>0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166377</td>
      <td>2019-08-05 00:00:00+03:00</td>
      <td>out</td>
      <td>True</td>
      <td>880020.0</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166377</td>
      <td>2019-08-05 00:00:00+03:00</td>
      <td>out</td>
      <td>True</td>
      <td>880020.0</td>
      <td>False</td>
      <td>1</td>
      <td>10</td>
      <td>18</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166377</td>
      <td>2019-08-05 00:00:00+03:00</td>
      <td>out</td>
      <td>False</td>
      <td>880022.0</td>
      <td>True</td>
      <td>3</td>
      <td>0</td>
      <td>25</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>53897</th>
      <td>168606</td>
      <td>2019-11-10 00:00:00+03:00</td>
      <td>out</td>
      <td>True</td>
      <td>957922.0</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>38</td>
    </tr>
    <tr>
      <th>53898</th>
      <td>168606</td>
      <td>2019-11-11 00:00:00+03:00</td>
      <td>out</td>
      <td>True</td>
      <td>957922.0</td>
      <td>False</td>
      <td>2</td>
      <td>479</td>
      <td>501</td>
    </tr>
    <tr>
      <th>53899</th>
      <td>168606</td>
      <td>2019-11-15 00:00:00+03:00</td>
      <td>out</td>
      <td>True</td>
      <td>957922.0</td>
      <td>False</td>
      <td>4</td>
      <td>3130</td>
      <td>3190</td>
    </tr>
    <tr>
      <th>53900</th>
      <td>168606</td>
      <td>2019-11-15 00:00:00+03:00</td>
      <td>out</td>
      <td>True</td>
      <td>957922.0</td>
      <td>False</td>
      <td>4</td>
      <td>3130</td>
      <td>3190</td>
    </tr>
    <tr>
      <th>53901</th>
      <td>168606</td>
      <td>2019-11-19 00:00:00+03:00</td>
      <td>in</td>
      <td>False</td>
      <td>NaN</td>
      <td>True</td>
      <td>2</td>
      <td>0</td>
      <td>64</td>
    </tr>
  </tbody>
</table>
<p>53902 rows × 9 columns</p>
</div>



В принципе таблица выглядит неплохо, но у колонки 'date' неверный тип. Зачем-то стоит часовой пояс. Помимо всего этого нет точного времени звонка. Только дата. Поэтому рекомендуется в данной колонке оставить только дату, приведя к необходимому типу.

Колонка 'internal' имеет неправильный тип, т.к. данные в колонке относятся к логическому типу **bool**.

Желательно колонку 'operator_id' перевести в целочисленный тип **int**, т.к. id бывают только целочисленными.

Проанализируем датасет на наличие полных дубликатов.


```python
td.duplicated().sum()
```




    4900



Многовато. Во время предобработки нужно будет решить что с ними делать.

Пришла пора получше познакомиться с клиентами.

### Анализ датасета 'telecom_clients'

Посмотрим на общую информацию о датасете:


```python
tc.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 732 entries, 0 to 731
    Data columns (total 3 columns):
     #   Column       Non-Null Count  Dtype 
    ---  ------       --------------  ----- 
     0   user_id      732 non-null    int64 
     1   tariff_plan  732 non-null    object
     2   date_start   732 non-null    object
    dtypes: int64(1), object(2)
    memory usage: 17.3+ KB


Скромно. 732 строки и 3 столбца. Нам же лучше) Тут только колонка 'date_start' выделяется, имея неверный тип.

Посмотрим на общее количество уникальных клиентов:


```python
tc.user_id.nunique()
```




    732



Одинаковое количество строк и клиентов, по 732. Следовательно, дубликатов в данном датасете нет.

По аналогии с '**telecom_dataset**' посмотрим как выглядит таблица. Выведем первые 5 строк:


```python
tc
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>user_id</th>
      <th>tariff_plan</th>
      <th>date_start</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166713</td>
      <td>A</td>
      <td>2019-08-15</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166901</td>
      <td>A</td>
      <td>2019-08-23</td>
    </tr>
    <tr>
      <th>2</th>
      <td>168527</td>
      <td>A</td>
      <td>2019-10-29</td>
    </tr>
    <tr>
      <th>3</th>
      <td>167097</td>
      <td>A</td>
      <td>2019-09-01</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168193</td>
      <td>A</td>
      <td>2019-10-16</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>727</th>
      <td>166554</td>
      <td>B</td>
      <td>2019-08-08</td>
    </tr>
    <tr>
      <th>728</th>
      <td>166911</td>
      <td>B</td>
      <td>2019-08-23</td>
    </tr>
    <tr>
      <th>729</th>
      <td>167012</td>
      <td>B</td>
      <td>2019-08-28</td>
    </tr>
    <tr>
      <th>730</th>
      <td>166867</td>
      <td>B</td>
      <td>2019-08-22</td>
    </tr>
    <tr>
      <th>731</th>
      <td>166565</td>
      <td>B</td>
      <td>2019-08-08</td>
    </tr>
  </tbody>
</table>
<p>732 rows × 3 columns</p>
</div>



Сразу сформируем общий вывод по датасетам.

### Вывод

При предварительном анализе датасетов можно выделить следующие моменты:

В датасете '**telecom_dataset**':
- Всего в таблице 53 902 строк и 9 колонок;
- В 2-х колонках есть пропуски: 'internal' и 'operator_id';
- Названия колонок не имеют нарушения стилей;
- Колонки 'date', 'internal' и 'operator_id' имеют неверный тип;
- Датасет имеет 4 900 полных дубликатов.

В датасете '**telecom_client**':

- Всего в таблице 732 строки и 3 колонки;
- В колонках пропусков нет;
- Названия колонок не имеют нарушения стилей;
- Колонка 'date_start' имеет неверный тип;

Вывод по каждому датасету сформирован. Есть над чем работать и что обрабатывать. Анализ датасетов на наличие "аномалий" выполним во время предобработки.

Данных для проведения исследования достаточно. Приступаем к предобработке данных.

## Предобработка данных

Сделаем предобработку по устоявшемуся порядку, сначала датасет '**telecom_dataset**', потом '**telecom_client**'.

Сначала возьмёмся за пропуски.

### Обработка пропусков

В данном случае пропуски у нас есть только в датасете '**telecom_dataset**'.

#### Обработка пропусков в 'telecom_dataset'

Посмотрим сколько их в датасете:


```python
td.isna().sum()
```




    user_id                   0
    date                      0
    direction                 0
    internal                117
    operator_id            8172
    is_missed_call            0
    calls_count               0
    call_duration             0
    total_call_duration       0
    dtype: int64



Один из ревьюйеров мне подсказал прикольный приём для визуализации пропущенных значений через библиотеку missingno:

Установим пакет и импортируем библиотеку missingno:


```python
pip install missingno
```

    Requirement already satisfied: missingno in /opt/conda/lib/python3.9/site-packages (0.5.2)
    Requirement already satisfied: numpy in /opt/conda/lib/python3.9/site-packages (from missingno) (1.21.1)
    Requirement already satisfied: seaborn in /opt/conda/lib/python3.9/site-packages (from missingno) (0.11.1)
    Requirement already satisfied: matplotlib in /opt/conda/lib/python3.9/site-packages (from missingno) (3.3.4)
    Requirement already satisfied: scipy in /opt/conda/lib/python3.9/site-packages (from missingno) (1.9.1)
    Requirement already satisfied: cycler>=0.10 in /opt/conda/lib/python3.9/site-packages (from matplotlib->missingno) (0.11.0)
    Requirement already satisfied: pillow>=6.2.0 in /opt/conda/lib/python3.9/site-packages (from matplotlib->missingno) (8.4.0)
    Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,>=2.0.3 in /opt/conda/lib/python3.9/site-packages (from matplotlib->missingno) (2.4.7)
    Requirement already satisfied: kiwisolver>=1.0.1 in /opt/conda/lib/python3.9/site-packages (from matplotlib->missingno) (1.4.4)
    Requirement already satisfied: python-dateutil>=2.1 in /opt/conda/lib/python3.9/site-packages (from matplotlib->missingno) (2.8.1)
    Requirement already satisfied: six>=1.5 in /opt/conda/lib/python3.9/site-packages (from python-dateutil>=2.1->matplotlib->missingno) (1.16.0)
    Requirement already satisfied: pandas>=0.23 in /opt/conda/lib/python3.9/site-packages (from seaborn->missingno) (1.2.4)
    Requirement already satisfied: pytz>=2017.3 in /opt/conda/lib/python3.9/site-packages (from pandas>=0.23->seaborn->missingno) (2021.1)
    Note: you may need to restart the kernel to use updated packages.



```python
import missingno as msno

msno.bar(td)
```




    <AxesSubplot:>




    
![png](output_63_1.png)
    


Либо совсем разойтись и добавить фон через библиотеку seaborn:


```python
import seaborn as sns
sns.set()
msno.bar(td)
```




    <AxesSubplot:>




    
![png](output_65_1.png)
    


*Далее постараюсь слишком много "воды" не добавлять.*

Можно также проанализировать через процентное соотношение, добавив несколько строк кода, но на мой взгляд так выглядит интереснее. В том числе, тут можно проанализировать примерную долю пропусков на фоне общего количества, т.к. точные цифры при оценке количества пропусков нам не нужны

**Вывод:**

В колонке 'operator_id' свыше 8 тысяч пропусков.

Если бы не было информации о том, что система просто не успела их назначить во время входящего вызова (особенности системы), то я бы подумал на данный вариант:

Возможно это как-то связано с входящими звонками, т.к. не всегда может определиться оператор звонка. Либо оператора нет в базе данных, чтобы он автоматически определился. На исходящем звонке понятно, что известен, но вот на входящем - вопрос. Возможно кто-то звонил со стационарного, с кодом города. Там фиг определишь к какому оператору привязан телефон. Это проверить несложно. Просто запросить у инженеров добавить хотя бы ещё один столбец с первыми 3 цифрами телефона ('+7' или '8' + '1-2 цифры'), в целях конфидициальности. Далее исключить все номера, которые начинаются с +79 или 89, т.к. с таких цифр начинаются только номера мобильных операторов.

Главный вопрос - как это может повлиять на конечный результат? На поставленные задачи никак не должно повлиять, т.к. это больше несёт информационный характер. Возможно только для дополнительного анализа, но в рамках нашего задания нам нет необходимости добавлять лишнюю "воду". В связи с этим считаю, что можно заполнить пропуски в данной колонке.

В колонке 'internal' всего 117 пропусков. Тут я думаю, что нет смысла даже предполагать причину, т.к. данное значение незначительно, относительно общего количества записей, и ничтожно повлияет на результат.

В связи с этим смело заполняем пропуски в обеих колонках значением, что нет информации, или для красоты всей картины - 'no information'.

Единственное, что  в колонке 'operator_id' 0 после запятой сильно бросается в глаза. Обычно id целочисленные. Можно было бы перевести их в целочисленный тип **int**, но не вижу смысла, т.к. значения данного столбца не пригодятся для вычислений. Поэтому можно не ставить заглушку, а прописать 'no information', предварительно создав вид целочисленного.


```python
import numpy as np

td['operator_id'] = td['operator_id'].replace(np.nan, 0)

td['operator_id'] = td['operator_id'].astype('int')
td['operator_id'] = td['operator_id'].replace(0, 'no information')
```


```python
for col_nan in ['internal']:
    td[col_nan] = td[col_nan].fillna('no information')
```

Посмотрим что получилось:


```python
td.isna().sum()
```




    user_id                0
    date                   0
    direction              0
    internal               0
    operator_id            0
    is_missed_call         0
    calls_count            0
    call_duration          0
    total_call_duration    0
    dtype: int64



Красиво. Идём дальше.

Теперь займёмся корректировкой типов колонок.

### Обработка типов данных

Обработаем типы данных в датасете '**telecom_dataset**':

#### Обработка типов данных датасета 'telecom_dataset'

Переводим тип данных в колонке 'date' в тип **date**, оставляя только дату.


```python
td['date'] = pd.to_datetime(td['date']).dt.date
td['date'] = pd.to_datetime(td['date'])
```

Переводим тип данных в колонке 'internal' в тип **bool**, чтобы задать данным логический тип.


```python
td['internal'] = td['internal'].astype('bool')
```

Посмотрим что получилось.


```python
td.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 53902 entries, 0 to 53901
    Data columns (total 9 columns):
     #   Column               Non-Null Count  Dtype         
    ---  ------               --------------  -----         
     0   user_id              53902 non-null  int64         
     1   date                 53902 non-null  datetime64[ns]
     2   direction            53902 non-null  object        
     3   internal             53902 non-null  bool          
     4   operator_id          53902 non-null  object        
     5   is_missed_call       53902 non-null  bool          
     6   calls_count          53902 non-null  int64         
     7   call_duration        53902 non-null  int64         
     8   total_call_duration  53902 non-null  int64         
    dtypes: bool(2), datetime64[ns](1), int64(4), object(2)
    memory usage: 3.0+ MB



```python
td
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>user_id</th>
      <th>date</th>
      <th>direction</th>
      <th>internal</th>
      <th>operator_id</th>
      <th>is_missed_call</th>
      <th>calls_count</th>
      <th>call_duration</th>
      <th>total_call_duration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>2019-08-04</td>
      <td>in</td>
      <td>False</td>
      <td>no information</td>
      <td>True</td>
      <td>2</td>
      <td>0</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>True</td>
      <td>880022</td>
      <td>True</td>
      <td>3</td>
      <td>0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>True</td>
      <td>880020</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>True</td>
      <td>880020</td>
      <td>False</td>
      <td>1</td>
      <td>10</td>
      <td>18</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>False</td>
      <td>880022</td>
      <td>True</td>
      <td>3</td>
      <td>0</td>
      <td>25</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>53897</th>
      <td>168606</td>
      <td>2019-11-10</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>38</td>
    </tr>
    <tr>
      <th>53898</th>
      <td>168606</td>
      <td>2019-11-11</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>False</td>
      <td>2</td>
      <td>479</td>
      <td>501</td>
    </tr>
    <tr>
      <th>53899</th>
      <td>168606</td>
      <td>2019-11-15</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>False</td>
      <td>4</td>
      <td>3130</td>
      <td>3190</td>
    </tr>
    <tr>
      <th>53900</th>
      <td>168606</td>
      <td>2019-11-15</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>False</td>
      <td>4</td>
      <td>3130</td>
      <td>3190</td>
    </tr>
    <tr>
      <th>53901</th>
      <td>168606</td>
      <td>2019-11-19</td>
      <td>in</td>
      <td>False</td>
      <td>no information</td>
      <td>True</td>
      <td>2</td>
      <td>0</td>
      <td>64</td>
    </tr>
  </tbody>
</table>
<p>53902 rows × 9 columns</p>
</div>



Все данные в столбцах приведены в удобные для анализа типы.

Приступаем к обработке данных датасета '**telecom_client**'.

#### Обработка типов данных датасета 'telecom_client'

Переводим тип данных в колонке 'date_start' в тип **date**.


```python
tc['date_start'] = pd.to_datetime(tc['date_start'])
```

Посмотрим что получилось.


```python
tc.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 732 entries, 0 to 731
    Data columns (total 3 columns):
     #   Column       Non-Null Count  Dtype         
    ---  ------       --------------  -----         
     0   user_id      732 non-null    int64         
     1   tariff_plan  732 non-null    object        
     2   date_start   732 non-null    datetime64[ns]
    dtypes: datetime64[ns](1), int64(1), object(1)
    memory usage: 17.3+ KB


Отлично! Обработали все типы данных и привелеи к необходимому типу.

Приступаем в обработке дубликатов.

### Обработка дубликатов

Ранее мы выяснили, что полные дубликаты есть только в датасете '**telecom_dataset**'. Причём в довольно таки большом количестве - 4 900.
Они нам точно не нужны и никак картину не испортят. Поэтому смело удаляем и сбрасываем индексы.


```python
td = td.drop_duplicates().reset_index()
del td['index']
td.duplicated().sum()
```




    0



Отлично. От полных дубликатов избавились. Теперь желательно проанализировать датасет на наличие неявных дубликатов.

В наших датасетах я не вижу столбцов, по котором можно искать неявные дубликаты. Был бы ещё адрес абонентов, осуществляющие входящие звонки на наших клиентов, то да. Ну а так. Пропускаем этот анализ.

Приступаем к обработке наименований колонок.

### Обработка "аномалий" в датасетах

К аномалиям будем относить "нереальные" значения в датасетах, т.е. либо слишком большие, либо слишком маленькие. В данном случае это возможно проанализировать только в датасете '**telecom_dataset**' со столбцами 'calls_count', 'call_duration' и 'total_call_duration'. Вряди кто-то совершает тысячи звонков, наговаривая часами с одним и тем же человеком.

Посмотрим на статистику данных столбцов.


```python
td[['calls_count', 'call_duration', 'total_call_duration']].describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>calls_count</th>
      <th>call_duration</th>
      <th>total_call_duration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>49002.000000</td>
      <td>49002.000000</td>
      <td>49002.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>16.462777</td>
      <td>866.282091</td>
      <td>1156.558202</td>
    </tr>
    <tr>
      <th>std</th>
      <td>63.604098</td>
      <td>3775.503352</td>
      <td>4451.473661</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>46.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>4.000000</td>
      <td>37.000000</td>
      <td>208.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>12.000000</td>
      <td>570.000000</td>
      <td>901.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>4817.000000</td>
      <td>144395.000000</td>
      <td>166155.000000</td>
    </tr>
  </tbody>
</table>
</div>



Максимальные значения впечатляют. Кто-то очень "болтливый".

Исходя из исходных данных, длительность звонков исчесляется в секундах, следовательно, максимальное количество секунд в день:

60 * 60 * 8 = 28 800 сек/день.

Предположим, что работодатель порядочный человек и соблюдает ТК РФ, а именно: сотрудник имеет право на перерыв после 4-х часов непрерывной работы, либо обед. Следовательно, максимальная длительность звонка с учётом времени ожидания в день может составлять: 28 800/2 = 14 400 сек/день.

Создадим переменную с учётом данных условий и посмотрим как изменится статистика в колонке 'total_call_duration' и в колонке 'call_duration'.


```python
td_tcd_cd = td.query('call_duration < 14400 and total_call_duration < 14400')
td_tcd_cd[['call_duration', 'total_call_duration']].describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>call_duration</th>
      <th>total_call_duration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>48617.000000</td>
      <td>48617.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>643.391653</td>
      <td>876.481807</td>
    </tr>
    <tr>
      <th>std</th>
      <td>1471.839898</td>
      <td>1731.423431</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.000000</td>
      <td>46.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>35.000000</td>
      <td>203.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>551.000000</td>
      <td>865.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>14110.000000</td>
      <td>14381.000000</td>
    </tr>
  </tbody>
</table>
</div>



Общее количество записей в столбцах сократилось менее чем на 400 строк, и, как следствие, статистические значения стали более реальными. В принципе, можем удалить строки с данными значениями.

Возникает сложность с определением аномалий в количестве звонков, т.к. в минуту можно названивать каждые несколько секунд на протяжении всех 4-х часов.


```python
td_pr = td.query('call_duration < 14400 and total_call_duration < 14400')
td_pr[['call_duration', 'total_call_duration']].describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>call_duration</th>
      <th>total_call_duration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>48617.000000</td>
      <td>48617.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>643.391653</td>
      <td>876.481807</td>
    </tr>
    <tr>
      <th>std</th>
      <td>1471.839898</td>
      <td>1731.423431</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.000000</td>
      <td>46.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>35.000000</td>
      <td>203.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>551.000000</td>
      <td>865.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>14110.000000</td>
      <td>14381.000000</td>
    </tr>
  </tbody>
</table>
</div>



Сделаем для этой колонки "ящик с усами" и посмотрим на выбросы.


```python
import matplotlib.pyplot as plt

plt.figure(figsize = (20,10))

sns.boxplot(data = td[['calls_count']])

plt.xticks(rotation = 45)
plt.ylabel('Количество звонков')
plt.title('Количество звонков')
```




    Text(0.5, 1.0, 'Количество звонков')




    
![png](output_107_1.png)
    


Любопытно как "расплющило".Есть даже рекордсмены, но нам на них не стоит равняться.
Сделаем ограничитель в районе 800 звонков.


```python
plt.figure(figsize = (20,10))

sns.boxplot(data = td[['calls_count']])

plt.xticks(rotation = 45)
plt.ylabel('Количество звонков')
plt.ylim(0, 800)
plt.title('Количество звонков')
```




    Text(0.5, 1.0, 'Количество звонков')




    
![png](output_109_1.png)
    


Выбросы начинаются примерно с 30 звонков. Посмотрим:


```python
plt.figure(figsize = (20,10))

sns.boxplot(data = td[['calls_count']])

plt.xticks(rotation = 45)
plt.ylabel('Количество звонков')
plt.ylim(0, 30)
plt.title('Количество звонков')
```




    Text(0.5, 1.0, 'Количество звонков')




    
![png](output_111_1.png)
    


Отлично. Верхний предел нашли. Теперь посмотрим сколько примерно значений находится за этими пределами.


```python
td_cc = td.query('calls_count < 30')
td_cc[['calls_count']].describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>calls_count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>43163.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>5.806038</td>
    </tr>
    <tr>
      <th>std</th>
      <td>6.484526</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>3.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>8.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>29.000000</td>
    </tr>
  </tbody>
</table>
</div>



Около 5,5 тысяч выбросов... Пу-пу-пууу. Многовато. Да и в принципе цифра больше похожа на работу очень "ленивых" колл-центров.

Нет общепринятой статистики сколько звонков в день должен делать оператор, т.к. на той же самой скорой помощи их может быть до полутысячи, а в обычном колл-центра до 150.

Возмём информацию с сайта: https://calldirect.ru/blog/skolko-zvonkov-dolzhen-delat-operator-koll-czentra/.

144 звонка. Округлим в большую сторону до 150 и возьмём за эталон. Далее посмотрим какое общее количество значений.


```python
td_cc = td.query('calls_count < 150')
td_cc[['calls_count']].describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>calls_count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>48443.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>11.598105</td>
    </tr>
    <tr>
      <th>std</th>
      <td>19.728240</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>4.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>12.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>149.000000</td>
    </tr>
  </tbody>
</table>
</div>



Ушло менее 200 звонков. Думаю, что их спокойно можно исключить из датасета.


```python
td_pr = td.query('calls_count < 150')
td_pr[['calls_count', 'call_duration', 'total_call_duration']].describe()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>calls_count</th>
      <th>call_duration</th>
      <th>total_call_duration</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>48443.000000</td>
      <td>48443.000000</td>
      <td>48443.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>11.598105</td>
      <td>681.447805</td>
      <td>888.357451</td>
    </tr>
    <tr>
      <th>std</th>
      <td>19.728240</td>
      <td>1662.748158</td>
      <td>1885.325336</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.000000</td>
      <td>0.000000</td>
      <td>45.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>4.000000</td>
      <td>37.000000</td>
      <td>201.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>12.000000</td>
      <td>560.000000</td>
      <td>852.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>149.000000</td>
      <td>26175.000000</td>
      <td>58027.000000</td>
    </tr>
  </tbody>
</table>
</div>



Избавились от "аномалий", которые очень сильно портили статистические данные.
Потеря в процентном отношении от общего количества данных:


```python
data_loss = (1-(len(td_pr)/len(td)))*100
print(round(data_loss, 2))
```

    1.14


Чуть более 1,14 %. Отлично. Идём дальше.

Следующим этапом у нас будет обработка наименований колонок.

Перед переименованием предлагаю объединить датасеты в один по общему ключу - колонке 'user_id'. Так будет проще ориентироваться и не создавать лишних строк кода.

### Объединение датасетов

Добавим датасет '**telecom_client**' к обновлённому датасету '**telecom_dataset**':


```python
telecom_date = td_pr.merge(tc, on = 'user_id', how = 'left')
telecom_date
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>user_id</th>
      <th>date</th>
      <th>direction</th>
      <th>internal</th>
      <th>operator_id</th>
      <th>is_missed_call</th>
      <th>calls_count</th>
      <th>call_duration</th>
      <th>total_call_duration</th>
      <th>tariff_plan</th>
      <th>date_start</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>2019-08-04</td>
      <td>in</td>
      <td>False</td>
      <td>no information</td>
      <td>True</td>
      <td>2</td>
      <td>0</td>
      <td>4</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>True</td>
      <td>880022</td>
      <td>True</td>
      <td>3</td>
      <td>0</td>
      <td>5</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>True</td>
      <td>880020</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>True</td>
      <td>880020</td>
      <td>False</td>
      <td>1</td>
      <td>10</td>
      <td>18</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>False</td>
      <td>880022</td>
      <td>True</td>
      <td>3</td>
      <td>0</td>
      <td>25</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>48438</th>
      <td>168606</td>
      <td>2019-11-10</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>False</td>
      <td>1</td>
      <td>0</td>
      <td>25</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
    <tr>
      <th>48439</th>
      <td>168606</td>
      <td>2019-11-10</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>38</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
    <tr>
      <th>48440</th>
      <td>168606</td>
      <td>2019-11-11</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>False</td>
      <td>2</td>
      <td>479</td>
      <td>501</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
    <tr>
      <th>48441</th>
      <td>168606</td>
      <td>2019-11-15</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>False</td>
      <td>4</td>
      <td>3130</td>
      <td>3190</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
    <tr>
      <th>48442</th>
      <td>168606</td>
      <td>2019-11-19</td>
      <td>in</td>
      <td>False</td>
      <td>no information</td>
      <td>True</td>
      <td>2</td>
      <td>0</td>
      <td>64</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
  </tbody>
</table>
<p>48443 rows × 11 columns</p>
</div>



Отлично. Теперь можем приступать к переименованию.

### Обработка наименований колонок

Я предполагаю, что не все аналитики знают английский язык. И поэтому, чтобы не запутаться и постоянно не обращаться к одному из ваших сервисов, я переведу наименования столбцов в привычную для нас кириллицу.

Посмотрим на наименования столбцов списком:


```python
telecom_date.columns
```




    Index(['user_id', 'date', 'direction', 'internal', 'operator_id',
           'is_missed_call', 'calls_count', 'call_duration', 'total_call_duration',
           'tariff_plan', 'date_start'],
          dtype='object')



Список наименований перед глазами. Теперь приступим к переименованию:


```python
telecom_date.rename(
    columns = {'user_id':'id клиента', 
               'date':'Дата звонка', 
               'direction':'Направление вызова', 
               'internal':'Внутренний вызов',
               'operator_id':'id оператора',
               'is_missed_call':'Вызов пропущен',
               'calls_count':'Количество звонков',
               'call_duration':'Длительность разговора',
               'total_call_duration':'Длительность звонка',
               'tariff_plan': 'Тарифный план',
               'date_start':'Дата регистрации в сервисе'
}, inplace = True
)

telecom_date
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Дата звонка</th>
      <th>Направление вызова</th>
      <th>Внутренний вызов</th>
      <th>id оператора</th>
      <th>Вызов пропущен</th>
      <th>Количество звонков</th>
      <th>Длительность разговора</th>
      <th>Длительность звонка</th>
      <th>Тарифный план</th>
      <th>Дата регистрации в сервисе</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>2019-08-04</td>
      <td>in</td>
      <td>False</td>
      <td>no information</td>
      <td>True</td>
      <td>2</td>
      <td>0</td>
      <td>4</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>True</td>
      <td>880022</td>
      <td>True</td>
      <td>3</td>
      <td>0</td>
      <td>5</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>True</td>
      <td>880020</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>True</td>
      <td>880020</td>
      <td>False</td>
      <td>1</td>
      <td>10</td>
      <td>18</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166377</td>
      <td>2019-08-05</td>
      <td>out</td>
      <td>False</td>
      <td>880022</td>
      <td>True</td>
      <td>3</td>
      <td>0</td>
      <td>25</td>
      <td>B</td>
      <td>2019-08-01</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>48438</th>
      <td>168606</td>
      <td>2019-11-10</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>False</td>
      <td>1</td>
      <td>0</td>
      <td>25</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
    <tr>
      <th>48439</th>
      <td>168606</td>
      <td>2019-11-10</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>38</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
    <tr>
      <th>48440</th>
      <td>168606</td>
      <td>2019-11-11</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>False</td>
      <td>2</td>
      <td>479</td>
      <td>501</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
    <tr>
      <th>48441</th>
      <td>168606</td>
      <td>2019-11-15</td>
      <td>out</td>
      <td>True</td>
      <td>957922</td>
      <td>False</td>
      <td>4</td>
      <td>3130</td>
      <td>3190</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
    <tr>
      <th>48442</th>
      <td>168606</td>
      <td>2019-11-19</td>
      <td>in</td>
      <td>False</td>
      <td>no information</td>
      <td>True</td>
      <td>2</td>
      <td>0</td>
      <td>64</td>
      <td>C</td>
      <td>2019-10-31</td>
    </tr>
  </tbody>
</table>
<p>48443 rows × 11 columns</p>
</div>



Так выглядит поприятнее. Можно также поменять значения в содержании таблицы на более понятные. К примеру 'in' на 'входящий', или переименовать логические выражения, но это уже на Ваше усмотрение.

### Вывод

Была проведена предобработка исходных данных перед началом исследовательского анализа, а именно:
- Заполнены пропуска в колонках 'internal' и 'operator_id' датасета '**telecom_dataset**';
- Изменён тип данных в колонках 'date', 'internal' и 'operator_id' датасета '**telecom_dataset**' и тип данных колонки 'date_start''**telecom_client**';
- Удалены полные дубликаты в датасете '**telecom_dataset**';
- Обработаны "аномалии" в колонках 'calls_count', 'call_duration' и 'total_call_duration' датасета '**telecom_dataset**';
- Датасеты объединены по колонке 'user_id' датасета '**telecom_dataset**';
- Названия колонок переименованы.

Считаю, что данные к исследовательскому анализу подготовлены.

## Исследовательский анализ

В начале исследовательского анализа нам необходимо выделить примерно 90 % самых активных клиентов из всего количества.

### Определение самых активных клиентов

Проанализируем количество клиентов на текущий момент:


```python
telecom_date['id клиента'].nunique()
```




    307



В общей сложности мы имеем 307 клиентов. Из них необходимо выделить самых активных. 

Активными клиентами являются те, кто совершает какое-либо действие согласно своим трудовым обязанностям. В данном случае основная задача сотрудников колл-центра - это звонки (входящие или исходящие) с целью контакта с клиентом.

Я считаю, что в данном случае это решение будет наиболее оптимальным, т.к. данные результаты мы будем показывать финансовому директору компании, а ему важны те сотрудники, которые приносят прибыль для компании, т.е. те, которые выполняют свои обязанности. Бывает, что "сверхактивные" сотрудники поднимают общую статистику за какой-то определённый период, а другие бездельничают, зная что за счёт этих "суперменов" весь отдел получит премию, или отработает норматив. Поэтому считаю, что нужно оценивать работу каждого по отдельности.

Считаем, что активными клиентами будут являться те, у кого было более 15 звонков.

Создадим таблицу, в которой выведем всех клиентов по отдельности в порядке убывания суммы количества звонков за исследуемый период.


```python
telecom_users = telecom_date.groupby(['id клиента'], as_index = False)['Количество звонков']\
                            .agg({'Количество звонков':'sum'})\
                            .sort_values(by = 'Количество звонков', ascending = False)\
                            .reset_index()
del telecom_users['index']

telecom_users
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Количество звонков</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>68543</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>58639</td>
    </tr>
    <tr>
      <th>2</th>
      <td>168062</td>
      <td>24547</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168252</td>
      <td>22375</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168187</td>
      <td>21398</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>302</th>
      <td>167682</td>
      <td>2</td>
    </tr>
    <tr>
      <th>303</th>
      <td>168340</td>
      <td>2</td>
    </tr>
    <tr>
      <th>304</th>
      <td>168013</td>
      <td>2</td>
    </tr>
    <tr>
      <th>305</th>
      <td>168578</td>
      <td>1</td>
    </tr>
    <tr>
      <th>306</th>
      <td>167981</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>307 rows × 2 columns</p>
</div>



Исключим из таблицы клиентов, которые совершили менее 15 звонков.


```python
active_users = telecom_users.query('`Количество звонков` > 15')
```

Посмотрим на количество данных пользователей:


```python
active_users['id клиента'].nunique()
```




    271



271 пользователей. Исключили примерно 12 % от всех пользователей, оставив только самых активных.

Выведем их в таблицу:


```python
telecom_au = active_users.groupby(['id клиента'], as_index = False)['Количество звонков']\
                         .agg({'Количество звонков':'sum'})\
                         .sort_values(by = 'Количество звонков', ascending = False)\
                         .reset_index()
telecom_au = telecom_au.rename(columns = {'Количество звонков': 'Общее количество звонков клиента'})
del telecom_au['index']

telecom_au
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Общее количество звонков клиента</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>68543</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>58639</td>
    </tr>
    <tr>
      <th>2</th>
      <td>168062</td>
      <td>24547</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168252</td>
      <td>22375</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168187</td>
      <td>21398</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>266</th>
      <td>168575</td>
      <td>17</td>
    </tr>
    <tr>
      <th>267</th>
      <td>166726</td>
      <td>17</td>
    </tr>
    <tr>
      <th>268</th>
      <td>168004</td>
      <td>17</td>
    </tr>
    <tr>
      <th>269</th>
      <td>167288</td>
      <td>16</td>
    </tr>
    <tr>
      <th>270</th>
      <td>168110</td>
      <td>16</td>
    </tr>
  </tbody>
</table>
<p>271 rows × 2 columns</p>
</div>



Клиент с id 167626 уж очень сильно выделяется. 68 543 звонка...
Сильно. Очень похоже на выброс, но ранее мы исключили эту вероятность. Поэтому возможно просто очень активный.

И так. Мы имеем 271 активных клиентов, у которых было более 15 звонков. С данными клиентами мы и будем работать дальше.

Присоединим к переменной оставшиеся колонки.


```python
telecom_date = telecom_au.merge(telecom_date, on = 'id клиента', how = 'left').reset_index()

del telecom_date['index']
telecom_date
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Общее количество звонков клиента</th>
      <th>Дата звонка</th>
      <th>Направление вызова</th>
      <th>Внутренний вызов</th>
      <th>id оператора</th>
      <th>Вызов пропущен</th>
      <th>Количество звонков</th>
      <th>Длительность разговора</th>
      <th>Длительность звонка</th>
      <th>Тарифный план</th>
      <th>Дата регистрации в сервисе</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>68543</td>
      <td>2019-09-24</td>
      <td>out</td>
      <td>False</td>
      <td>919164</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>22</td>
      <td>A</td>
      <td>2019-09-24</td>
    </tr>
    <tr>
      <th>1</th>
      <td>167626</td>
      <td>68543</td>
      <td>2019-09-24</td>
      <td>out</td>
      <td>False</td>
      <td>919194</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>14</td>
      <td>A</td>
      <td>2019-09-24</td>
    </tr>
    <tr>
      <th>2</th>
      <td>167626</td>
      <td>68543</td>
      <td>2019-09-24</td>
      <td>out</td>
      <td>False</td>
      <td>919166</td>
      <td>False</td>
      <td>1</td>
      <td>12</td>
      <td>23</td>
      <td>A</td>
      <td>2019-09-24</td>
    </tr>
    <tr>
      <th>3</th>
      <td>167626</td>
      <td>68543</td>
      <td>2019-09-24</td>
      <td>out</td>
      <td>False</td>
      <td>919188</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>8</td>
      <td>A</td>
      <td>2019-09-24</td>
    </tr>
    <tr>
      <th>4</th>
      <td>167626</td>
      <td>68543</td>
      <td>2019-09-24</td>
      <td>in</td>
      <td>False</td>
      <td>no information</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>12</td>
      <td>A</td>
      <td>2019-09-24</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>48279</th>
      <td>168110</td>
      <td>16</td>
      <td>2019-11-08</td>
      <td>in</td>
      <td>False</td>
      <td>no information</td>
      <td>True</td>
      <td>1</td>
      <td>0</td>
      <td>60</td>
      <td>C</td>
      <td>2019-10-14</td>
    </tr>
    <tr>
      <th>48280</th>
      <td>168110</td>
      <td>16</td>
      <td>2019-11-08</td>
      <td>in</td>
      <td>False</td>
      <td>938432</td>
      <td>False</td>
      <td>1</td>
      <td>62</td>
      <td>78</td>
      <td>C</td>
      <td>2019-10-14</td>
    </tr>
    <tr>
      <th>48281</th>
      <td>168110</td>
      <td>16</td>
      <td>2019-11-11</td>
      <td>in</td>
      <td>False</td>
      <td>no information</td>
      <td>True</td>
      <td>4</td>
      <td>0</td>
      <td>98</td>
      <td>C</td>
      <td>2019-10-14</td>
    </tr>
    <tr>
      <th>48282</th>
      <td>168110</td>
      <td>16</td>
      <td>2019-11-11</td>
      <td>in</td>
      <td>False</td>
      <td>938432</td>
      <td>False</td>
      <td>1</td>
      <td>32</td>
      <td>49</td>
      <td>C</td>
      <td>2019-10-14</td>
    </tr>
    <tr>
      <th>48283</th>
      <td>168110</td>
      <td>16</td>
      <td>2019-11-12</td>
      <td>in</td>
      <td>False</td>
      <td>938432</td>
      <td>False</td>
      <td>1</td>
      <td>45</td>
      <td>69</td>
      <td>C</td>
      <td>2019-10-14</td>
    </tr>
  </tbody>
</table>
<p>48284 rows × 12 columns</p>
</div>



Отлично. Теперь в таблице только активные клиенты.

### Портрет клиента

В данном подразделе проанализируем портрет клиента, а именно:
- Доля входящих и исходящих звонков;
- Доля пропущенных и принятых звонков;
- В какие месяцы проявлена наибольшая активность (относительно изучаемого периода);
- ТОП-10 клиентов.

#### Доля входящих и исходящих звонков

Определим долю в процентах входящих и исходящих звонков.


```python
in_call_percent = len(telecom_date[telecom_date['Направление вызова'] == 'in'])/len(telecom_date['Направление вызова'])*100
print(round(in_call_percent, 2), '%')
```

    40.92 %



```python
out_call_percent = 100 - in_call_percent
print(round(out_call_percent, 2), '%')
```

    59.08 %


Входящих звонков 40,92 % от общего количества. Следовательно, исходящих - 59.08 %.

Посмотрим на входящие и исходящие звонки во временом интервале:


```python
date_columns = ['Дата звонка']

out_call = telecom_date[telecom_date['Направление вызова'] == 'out']
in_call = telecom_date[telecom_date['Направление вызова'] == 'in']

plt.figure(figsize = (18,9))
plt.title('Распределение исходящий и входящих звонков во временном интервале', fontsize = 16)
for column in date_columns:
    plt.hist(out_call[column], bins = 100, alpha =.9, label = 'Исходящий звонок')
    plt.hist(in_call[column], bins = 100, alpha =.5, label = 'Входящий звонок')
    plt.xticks(rotation = 90)
    plt.ylabel('Количество звонков', fontsize = 14)
    plt.xlabel('Временной диапазон', fontsize = 14)
    plt.legend()
```


    
![png](output_160_0.png)
    


Примерное соотношение между входящими и исходящими заметно. Есть промежутки, в которых наблюдаются сильные спады. Предположительно это выходные, в которые большиство работников колл-центра отдыхают.

#### Доля пропущенных и принятых звонков

Определим долю в процентах пропущенных и принятых звонков.


```python
missed_call_percent = len(telecom_date[telecom_date['Вызов пропущен'] == True])/len(telecom_date['Вызов пропущен'])*100
print(round(missed_call_percent, 2), '%')
```

    43.6 %



```python
received_call_percent = 100 - missed_call_percent
print(round(received_call_percent, 2), '%')
```

    56.4 %


Пропущенных звонков 43,6 % от общего количества. Следовательно, принятых - 56,4 %. Почти пополам... Многовато пропущенных.

Посмотрим на пропущенные и принятые звонки во временом интервале:


```python
missed_call = telecom_date[telecom_date['Вызов пропущен'] == True]
received_call = telecom_date[telecom_date['Вызов пропущен'] == False]

plt.figure(figsize = (18,9))
plt.title('Распределение пропущенных и принятых звонков во временном интервале', fontsize = 16)
for column in date_columns:
    plt.hist(received_call[column], bins = 100, alpha = .7, label = 'Вызов принят')
    plt.hist(missed_call[column], bins = 100, alpha = .5, label = 'Вызов пропущен')
    plt.xticks(rotation = 90)
    plt.ylabel('Количество звонков', fontsize = 14)
    plt.xlabel('Временной диапазон', fontsize = 14)
    plt.legend()
```


    
![png](output_167_0.png)
    


Подозрительно много пропущенных звонков. Прослеживаются спады, но в данном случае причина аналогична как и с предыдущей гистограммой - выходные.



#### Доля звонков внутри сети

Проанализируем процент звонков внутри сети:


```python
in_network_percent = len(telecom_date[telecom_date['Внутренний вызов'] == True])/len(telecom_date['Внутренний вызов'])*100
print(round(in_network_percent, 2), '%')
```

    11.92 %


Не густо. Теперь посмотрим на процент звонков абонентам других операторов:


```python
out_network_percent = 100 - in_network_percent
print(round(out_network_percent, 2), '%')
```

    88.08 %



```python
in_network_call = telecom_date[telecom_date['Внутренний вызов'] == True]
out_network_call = telecom_date[telecom_date['Внутренний вызов'] == False]

plt.figure(figsize = (18,10))
plt.title('Распределение звонков внутри сети и другим оператором во временном интервале', fontsize = 16)
for column in date_columns:
    plt.hist(out_network_call[column], bins = 100, alpha =.5, label = 'Вне сети')
    plt.hist(in_network_call[column], bins = 100, alpha =.9, label = 'Внутри сети')
    plt.xticks(rotation = 90)
    plt.ylabel('Количество звонков', fontsize = 14)
    plt.xlabel('Временной диапазон', fontsize = 14)
    plt.legend()
```


    
![png](output_174_0.png)
    


Как ранее мы могли наблюадать. Почти 90 % от всех звонков приходятся звонки на других операторов.

Посмотрим на месяца наибольшей активности за исследуемый период.

#### Месяцы наибольшей активности

Посмотрим какой временной интервал нам предоставлен.


```python
telecom_date['Дата звонка'] = pd.to_datetime(telecom_date['Дата звонка']).dt.date

print('Дата начала статистики:', telecom_date['Дата звонка'].min())
print('Дата конца статистики:', telecom_date['Дата звонка'].max())

time_period = telecom_date['Дата звонка'].max() - telecom_date['Дата звонка'].min()

print(time_period)
```

    Дата начала статистики: 2019-08-02
    Дата конца статистики: 2019-11-28
    118 days, 0:00:00


У нас в запасе 118 дней, это где-то 4 месяца. С начала августа по конец ноября.

Добавим новый столбец с месяцем звонка:


```python
telecom_date['Месяц'] = pd.to_datetime(telecom_date['Дата звонка']).dt.month
```


```python
date_columns_month = ['Месяц']

plt.figure(figsize = (20,10))
plt.hist(telecom_date['Месяц'], bins = 15, align = 'left')
plt.title('Распределение количества звонков по месяцам', fontsize = 16)
plt.ylabel('Количество звонков', fontsize = 14)
plt.xlabel('Временный период', fontsize = 14)
plt.show()
```


    
![png](output_182_0.png)
    


Заметно явное увеличение количества звонков к концу года. Практические линейный рост.

Возможно это как-то связано с большим количеством регистраций на сервисе, из-за чего количество "рабочих рук" возросло.

Посмотрим на распределение регистраций на сервисе относительно изучаемого промежутка времени.


```python
plt.figure(figsize = (18,10))
plt.hist(telecom_date['Дата регистрации в сервисе'], bins = 100)
plt.title('Распределение количества регистрация во временной диапазоне')
plt.ylabel('Количество регистраций')
plt.xlabel('Временной диапазон')
plt.show()
```


    
![png](output_185_0.png)
    


Да нет. Я бы так не сказал. Более или менее равномерно. Возможно это связано с предстоящими праздниками, хотя там ещё далеко. Либо люди так длительно "просыпались" после отпусков. Либо всё вместе.

#### ТОП-10

Вернёмся к нашей переменной, которая показывает список самых активных пользователей по убыванию количества звонков:


```python
telecom_au
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Общее количество звонков клиента</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>68543</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>58639</td>
    </tr>
    <tr>
      <th>2</th>
      <td>168062</td>
      <td>24547</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168252</td>
      <td>22375</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168187</td>
      <td>21398</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>266</th>
      <td>168575</td>
      <td>17</td>
    </tr>
    <tr>
      <th>267</th>
      <td>166726</td>
      <td>17</td>
    </tr>
    <tr>
      <th>268</th>
      <td>168004</td>
      <td>17</td>
    </tr>
    <tr>
      <th>269</th>
      <td>167288</td>
      <td>16</td>
    </tr>
    <tr>
      <th>270</th>
      <td>168110</td>
      <td>16</td>
    </tr>
  </tbody>
</table>
<p>271 rows × 2 columns</p>
</div>



Для большей информативности таблицы добавим к ней колонки с общим количеством секунд разговора и общим временем звонка.


```python
telecom_cd = telecom_date.groupby(['id клиента'], as_index = False)['Длительность разговора']\
                         .agg({'Длительность разговора':'sum'})\
                         .sort_values(by = 'Длительность разговора', ascending = False)\
                         .reset_index()

telecom_cd = telecom_cd.rename(columns = {'Длительность разговора': 'Общее время разговора клиента, сек.'})
del telecom_cd['index']

telecom_cd
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Общее время разговора клиента, сек.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>168361</td>
      <td>4109075</td>
    </tr>
    <tr>
      <th>1</th>
      <td>167626</td>
      <td>3122180</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166658</td>
      <td>2357306</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168252</td>
      <td>1575237</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166405</td>
      <td>1152149</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>266</th>
      <td>167631</td>
      <td>0</td>
    </tr>
    <tr>
      <th>267</th>
      <td>168291</td>
      <td>0</td>
    </tr>
    <tr>
      <th>268</th>
      <td>168024</td>
      <td>0</td>
    </tr>
    <tr>
      <th>269</th>
      <td>167122</td>
      <td>0</td>
    </tr>
    <tr>
      <th>270</th>
      <td>167077</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>271 rows × 2 columns</p>
</div>




```python
telecom_tcd = telecom_date.groupby(['id клиента'], as_index = False)['Длительность звонка']\
                          .agg({'Длительность звонка':'sum'})\
                          .sort_values(by = 'Длительность звонка', ascending = False)\
                          .reset_index()
telecom_tcd = telecom_tcd.rename(columns = {'Длительность звонка': 'Общее время звонка, сек.'})
del telecom_tcd['index']

telecom_tcd
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Общее время звонка, сек.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>168361</td>
      <td>5362733</td>
    </tr>
    <tr>
      <th>1</th>
      <td>167626</td>
      <td>4552148</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166658</td>
      <td>2560455</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168252</td>
      <td>1876096</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168187</td>
      <td>1575719</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>266</th>
      <td>168024</td>
      <td>143</td>
    </tr>
    <tr>
      <th>267</th>
      <td>167840</td>
      <td>141</td>
    </tr>
    <tr>
      <th>268</th>
      <td>167077</td>
      <td>96</td>
    </tr>
    <tr>
      <th>269</th>
      <td>166481</td>
      <td>68</td>
    </tr>
    <tr>
      <th>270</th>
      <td>167631</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>271 rows × 2 columns</p>
</div>



Заодно добавим колонку со временем ожидания ответа для каждого клиента.


```python
telecom_date['Общее время ожидания, сек.'] = (telecom_date['Длительность звонка'] - telecom_date['Длительность разговора'])/telecom_date['Количество звонков']

telecom_wt = telecom_date.groupby(['id клиента'], as_index = False)['Общее время ожидания, сек.']\
                         .agg({'Общее время ожидания, сек.':'sum'})\
                         .sort_values(by = 'Общее время ожидания, сек.', ascending = False)\
                         .reset_index()

del telecom_wt['index']

telecom_wt
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Общее время ожидания, сек.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>168187</td>
      <td>42938.605505</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166658</td>
      <td>32212.986508</td>
    </tr>
    <tr>
      <th>2</th>
      <td>167497</td>
      <td>25048.638233</td>
    </tr>
    <tr>
      <th>3</th>
      <td>167626</td>
      <td>23042.833381</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168361</td>
      <td>22754.651926</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>266</th>
      <td>168315</td>
      <td>25.525320</td>
    </tr>
    <tr>
      <th>267</th>
      <td>167599</td>
      <td>20.745469</td>
    </tr>
    <tr>
      <th>268</th>
      <td>168190</td>
      <td>17.250000</td>
    </tr>
    <tr>
      <th>269</th>
      <td>166481</td>
      <td>15.542764</td>
    </tr>
    <tr>
      <th>270</th>
      <td>167631</td>
      <td>0.000000</td>
    </tr>
  </tbody>
</table>
<p>271 rows × 2 columns</p>
</div>



Для дальнейшей аналитики тарифных планов добавим одноименную колонку, чтобы понять кто какой тариф использует.


```python
telecom_tp = telecom_date.groupby(['id клиента'], as_index = False)['Тарифный план'].first()
telecom_tp
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>B</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166391</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166392</td>
      <td>C</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166399</td>
      <td>C</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166405</td>
      <td>B</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>266</th>
      <td>168579</td>
      <td>B</td>
    </tr>
    <tr>
      <th>267</th>
      <td>168583</td>
      <td>B</td>
    </tr>
    <tr>
      <th>268</th>
      <td>168598</td>
      <td>C</td>
    </tr>
    <tr>
      <th>269</th>
      <td>168601</td>
      <td>C</td>
    </tr>
    <tr>
      <th>270</th>
      <td>168606</td>
      <td>C</td>
    </tr>
  </tbody>
</table>
<p>271 rows × 2 columns</p>
</div>



А теперь всё добавляем к таблице с общим количеством звонков:


```python
telecom_au = telecom_au.merge(telecom_cd, on = 'id клиента', how = 'left')
telecom_au = telecom_au.merge(telecom_tcd, on = 'id клиента', how = 'left')
telecom_au = (round(telecom_au.merge(telecom_wt, on = 'id клиента', how = 'left'), 0)).astype('int')
telecom_au = telecom_au.merge(telecom_tp, on = 'id клиента', how = 'left')
telecom_au
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Общее количество звонков клиента</th>
      <th>Общее время разговора клиента, сек.</th>
      <th>Общее время звонка, сек.</th>
      <th>Общее время ожидания, сек.</th>
      <th>Тарифный план</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>68543</td>
      <td>3122180</td>
      <td>4552148</td>
      <td>23043</td>
      <td>A</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>58639</td>
      <td>4109075</td>
      <td>5362733</td>
      <td>22755</td>
      <td>A</td>
    </tr>
    <tr>
      <th>2</th>
      <td>168062</td>
      <td>24547</td>
      <td>610021</td>
      <td>1055271</td>
      <td>16427</td>
      <td>A</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168252</td>
      <td>22375</td>
      <td>1575237</td>
      <td>1876096</td>
      <td>10568</td>
      <td>A</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168187</td>
      <td>21398</td>
      <td>1140608</td>
      <td>1575719</td>
      <td>42939</td>
      <td>A</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>266</th>
      <td>168575</td>
      <td>17</td>
      <td>589</td>
      <td>862</td>
      <td>196</td>
      <td>C</td>
    </tr>
    <tr>
      <th>267</th>
      <td>166726</td>
      <td>17</td>
      <td>480</td>
      <td>755</td>
      <td>232</td>
      <td>C</td>
    </tr>
    <tr>
      <th>268</th>
      <td>168004</td>
      <td>17</td>
      <td>45</td>
      <td>313</td>
      <td>219</td>
      <td>C</td>
    </tr>
    <tr>
      <th>269</th>
      <td>167288</td>
      <td>16</td>
      <td>44</td>
      <td>164</td>
      <td>117</td>
      <td>B</td>
    </tr>
    <tr>
      <th>270</th>
      <td>168110</td>
      <td>16</td>
      <td>1335</td>
      <td>1751</td>
      <td>273</td>
      <td>C</td>
    </tr>
  </tbody>
</table>
<p>271 rows × 6 columns</p>
</div>



А теперь посмотрим на ТОП-10 по количеству звонков.


```python
telecom_au.head(10)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Общее количество звонков клиента</th>
      <th>Общее время разговора клиента, сек.</th>
      <th>Общее время звонка, сек.</th>
      <th>Общее время ожидания, сек.</th>
      <th>Тарифный план</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>68543</td>
      <td>3122180</td>
      <td>4552148</td>
      <td>23043</td>
      <td>A</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>58639</td>
      <td>4109075</td>
      <td>5362733</td>
      <td>22755</td>
      <td>A</td>
    </tr>
    <tr>
      <th>2</th>
      <td>168062</td>
      <td>24547</td>
      <td>610021</td>
      <td>1055271</td>
      <td>16427</td>
      <td>A</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168252</td>
      <td>22375</td>
      <td>1575237</td>
      <td>1876096</td>
      <td>10568</td>
      <td>A</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168187</td>
      <td>21398</td>
      <td>1140608</td>
      <td>1575719</td>
      <td>42939</td>
      <td>A</td>
    </tr>
    <tr>
      <th>5</th>
      <td>167125</td>
      <td>15127</td>
      <td>810710</td>
      <td>1125330</td>
      <td>9823</td>
      <td>C</td>
    </tr>
    <tr>
      <th>6</th>
      <td>166405</td>
      <td>15111</td>
      <td>1152149</td>
      <td>1434562</td>
      <td>18359</td>
      <td>B</td>
    </tr>
    <tr>
      <th>7</th>
      <td>166582</td>
      <td>13471</td>
      <td>413740</td>
      <td>677673</td>
      <td>6038</td>
      <td>A</td>
    </tr>
    <tr>
      <th>8</th>
      <td>166658</td>
      <td>12794</td>
      <td>2357306</td>
      <td>2560455</td>
      <td>32213</td>
      <td>B</td>
    </tr>
    <tr>
      <th>9</th>
      <td>167650</td>
      <td>12645</td>
      <td>622495</td>
      <td>873071</td>
      <td>11301</td>
      <td>C</td>
    </tr>
  </tbody>
</table>
</div>



#### Вывод

В принципе портрет самых активынх пользователей составлен. Кто-то очень любит поболтать, кто-то имеет колосальное терпение в ожидании ответа на звонок. При необходимости можно всё это перевести в минуты, или часы, но предварительно можно оценить на кого стоит ориентироваться при анализе перспективных клиентов на смену тарифа. В том числе, на какой месяц делать акцент и что явлется "ключом" к сердцу клиента.

Подробнее это разберём в следующем разделе, в котором будем оценивать преимущества тарифных планов для тех или иных клиентов.

### Кто и сколько активных клиентов переплачивают на текущих тарифных планах

Активными клиентами могут считаться не только те, кто совершает звонок, но и те, кто принимает. Они также выполняют свою работу, но находясь только "на приёме". Проанализируем сколько активных клиентов находятся только в качестве "принимающих", чтобы можно было бы предложить им самый дешёвый тариф C, т.к. входящие на всех тарифах бесплатны.

#### Активные клиенты, которые переплачивают на входящих звонках.

Посмотрим на клиентов, которые только принимали звонки:


```python
telecom_d_in = in_call.groupby(['id клиента'], as_index = False)['Тарифный план'].first()
telecom_d_in
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>B</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166391</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166392</td>
      <td>C</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166399</td>
      <td>C</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166405</td>
      <td>B</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>266</th>
      <td>168579</td>
      <td>B</td>
    </tr>
    <tr>
      <th>267</th>
      <td>168583</td>
      <td>B</td>
    </tr>
    <tr>
      <th>268</th>
      <td>168598</td>
      <td>C</td>
    </tr>
    <tr>
      <th>269</th>
      <td>168601</td>
      <td>C</td>
    </tr>
    <tr>
      <th>270</th>
      <td>168606</td>
      <td>C</td>
    </tr>
  </tbody>
</table>
<p>271 rows × 2 columns</p>
</div>



Теперь посмотрим на клиентов, которые не только принимали, но и совершали исходящие звонки:


```python
telecom_d_out = out_call.groupby(['id клиента'], as_index = False)['Направление вызова'].first()
telecom_d_out = telecom_d_out.merge(telecom_tp, on = 'id клиента', how = 'left')

del telecom_d_out['Направление вызова']
telecom_d_out
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>B</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166391</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166405</td>
      <td>B</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166406</td>
      <td>B</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166407</td>
      <td>A</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>168466</td>
      <td>C</td>
    </tr>
    <tr>
      <th>210</th>
      <td>168473</td>
      <td>C</td>
    </tr>
    <tr>
      <th>211</th>
      <td>168481</td>
      <td>B</td>
    </tr>
    <tr>
      <th>212</th>
      <td>168601</td>
      <td>C</td>
    </tr>
    <tr>
      <th>213</th>
      <td>168606</td>
      <td>C</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 2 columns</p>
</div>



Всего 214 клиентов совершали исходящие звонки.

Видна разница. Выведем список тех, кто только принимает звонки.


```python
diff_in_out = pd.merge(telecom_d_in, telecom_d_out, on = ['id клиента','Тарифный план'], how = 'outer', indicator = True)\
                .query("_merge != 'both'")\
                .drop('_merge', axis = 1)\
                .reset_index(drop = True)
diff_in_out
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166392</td>
      <td>C</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166399</td>
      <td>C</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166428</td>
      <td>B</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166481</td>
      <td>A</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166482</td>
      <td>C</td>
    </tr>
    <tr>
      <th>5</th>
      <td>166548</td>
      <td>B</td>
    </tr>
    <tr>
      <th>6</th>
      <td>166649</td>
      <td>C</td>
    </tr>
    <tr>
      <th>7</th>
      <td>166726</td>
      <td>C</td>
    </tr>
    <tr>
      <th>8</th>
      <td>166727</td>
      <td>C</td>
    </tr>
    <tr>
      <th>9</th>
      <td>166836</td>
      <td>C</td>
    </tr>
    <tr>
      <th>10</th>
      <td>166837</td>
      <td>B</td>
    </tr>
    <tr>
      <th>11</th>
      <td>166879</td>
      <td>A</td>
    </tr>
    <tr>
      <th>12</th>
      <td>166896</td>
      <td>A</td>
    </tr>
    <tr>
      <th>13</th>
      <td>166908</td>
      <td>C</td>
    </tr>
    <tr>
      <th>14</th>
      <td>166955</td>
      <td>C</td>
    </tr>
    <tr>
      <th>15</th>
      <td>166975</td>
      <td>B</td>
    </tr>
    <tr>
      <th>16</th>
      <td>166985</td>
      <td>C</td>
    </tr>
    <tr>
      <th>17</th>
      <td>167059</td>
      <td>C</td>
    </tr>
    <tr>
      <th>18</th>
      <td>167077</td>
      <td>B</td>
    </tr>
    <tr>
      <th>19</th>
      <td>167079</td>
      <td>C</td>
    </tr>
    <tr>
      <th>20</th>
      <td>167102</td>
      <td>C</td>
    </tr>
    <tr>
      <th>21</th>
      <td>167158</td>
      <td>A</td>
    </tr>
    <tr>
      <th>22</th>
      <td>167162</td>
      <td>C</td>
    </tr>
    <tr>
      <th>23</th>
      <td>167272</td>
      <td>C</td>
    </tr>
    <tr>
      <th>24</th>
      <td>167277</td>
      <td>C</td>
    </tr>
    <tr>
      <th>25</th>
      <td>167286</td>
      <td>C</td>
    </tr>
    <tr>
      <th>26</th>
      <td>167402</td>
      <td>B</td>
    </tr>
    <tr>
      <th>27</th>
      <td>167474</td>
      <td>C</td>
    </tr>
    <tr>
      <th>28</th>
      <td>167506</td>
      <td>C</td>
    </tr>
    <tr>
      <th>29</th>
      <td>167534</td>
      <td>C</td>
    </tr>
    <tr>
      <th>30</th>
      <td>167631</td>
      <td>A</td>
    </tr>
    <tr>
      <th>31</th>
      <td>167664</td>
      <td>C</td>
    </tr>
    <tr>
      <th>32</th>
      <td>167744</td>
      <td>C</td>
    </tr>
    <tr>
      <th>33</th>
      <td>167781</td>
      <td>C</td>
    </tr>
    <tr>
      <th>34</th>
      <td>167792</td>
      <td>C</td>
    </tr>
    <tr>
      <th>35</th>
      <td>167847</td>
      <td>B</td>
    </tr>
    <tr>
      <th>36</th>
      <td>167870</td>
      <td>C</td>
    </tr>
    <tr>
      <th>37</th>
      <td>167908</td>
      <td>B</td>
    </tr>
    <tr>
      <th>38</th>
      <td>167936</td>
      <td>C</td>
    </tr>
    <tr>
      <th>39</th>
      <td>167976</td>
      <td>C</td>
    </tr>
    <tr>
      <th>40</th>
      <td>168004</td>
      <td>C</td>
    </tr>
    <tr>
      <th>41</th>
      <td>168016</td>
      <td>C</td>
    </tr>
    <tr>
      <th>42</th>
      <td>168024</td>
      <td>C</td>
    </tr>
    <tr>
      <th>43</th>
      <td>168041</td>
      <td>B</td>
    </tr>
    <tr>
      <th>44</th>
      <td>168054</td>
      <td>C</td>
    </tr>
    <tr>
      <th>45</th>
      <td>168110</td>
      <td>C</td>
    </tr>
    <tr>
      <th>46</th>
      <td>168190</td>
      <td>C</td>
    </tr>
    <tr>
      <th>47</th>
      <td>168264</td>
      <td>C</td>
    </tr>
    <tr>
      <th>48</th>
      <td>168315</td>
      <td>B</td>
    </tr>
    <tr>
      <th>49</th>
      <td>168366</td>
      <td>C</td>
    </tr>
    <tr>
      <th>50</th>
      <td>168377</td>
      <td>B</td>
    </tr>
    <tr>
      <th>51</th>
      <td>168464</td>
      <td>C</td>
    </tr>
    <tr>
      <th>52</th>
      <td>168522</td>
      <td>C</td>
    </tr>
    <tr>
      <th>53</th>
      <td>168575</td>
      <td>C</td>
    </tr>
    <tr>
      <th>54</th>
      <td>168579</td>
      <td>B</td>
    </tr>
    <tr>
      <th>55</th>
      <td>168583</td>
      <td>B</td>
    </tr>
    <tr>
      <th>56</th>
      <td>168598</td>
      <td>C</td>
    </tr>
  </tbody>
</table>
</div>



Теперь исключим из него клиентов, которые пользуются самым недорогим тарифом С.


```python
diff_in_out_AB = diff_in_out.query('`Тарифный план` != "C"').reset_index(drop = True)

diff_in_out_AB
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166428</td>
      <td>B</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166481</td>
      <td>A</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166548</td>
      <td>B</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166837</td>
      <td>B</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166879</td>
      <td>A</td>
    </tr>
    <tr>
      <th>5</th>
      <td>166896</td>
      <td>A</td>
    </tr>
    <tr>
      <th>6</th>
      <td>166975</td>
      <td>B</td>
    </tr>
    <tr>
      <th>7</th>
      <td>167077</td>
      <td>B</td>
    </tr>
    <tr>
      <th>8</th>
      <td>167158</td>
      <td>A</td>
    </tr>
    <tr>
      <th>9</th>
      <td>167402</td>
      <td>B</td>
    </tr>
    <tr>
      <th>10</th>
      <td>167631</td>
      <td>A</td>
    </tr>
    <tr>
      <th>11</th>
      <td>167847</td>
      <td>B</td>
    </tr>
    <tr>
      <th>12</th>
      <td>167908</td>
      <td>B</td>
    </tr>
    <tr>
      <th>13</th>
      <td>168041</td>
      <td>B</td>
    </tr>
    <tr>
      <th>14</th>
      <td>168315</td>
      <td>B</td>
    </tr>
    <tr>
      <th>15</th>
      <td>168377</td>
      <td>B</td>
    </tr>
    <tr>
      <th>16</th>
      <td>168579</td>
      <td>B</td>
    </tr>
    <tr>
      <th>17</th>
      <td>168583</td>
      <td>B</td>
    </tr>
  </tbody>
</table>
</div>



Отлично. Теперь у нас есть список клиентов, которым однозначно можно предложить перейти на тариф С, т.к. они принимают только входящие звонки, а самый недорогой тариф, у которого все входящие бесплатны, тариф С.

#### Анализ клиентов, которые переплачивают на исходящих звонках

Теперь необходимо создать общую таблицу, в которой останутся только то, кто делал исходящие звонки. Также к ней будут добавлены данные, необходимые для калькуляции выгоды.

Для начала создадим две отдельные таблицы, которые впоследстии также объединим. В них будет следующая информация: 
1. Количество исходящих звонков внутри сети;
2. Исходящие звонки абонентам других операторов.

Количество исходящих звонков внутри сети:


```python
telecom_cc_true = out_call.query('`Внутренний вызов` == True')
```


```python
telecom_au_out_cc1 = telecom_cc_true.groupby(['id клиента'], as_index = False)['Количество звонков']\
                                   .agg({'Количество звонков':'sum'})\
                                   .sort_values(by = 'Количество звонков', ascending = False)\
                                   .reset_index()
telecom_au_out_cc1 = telecom_au_out_cc1.rename(columns = {'Количество звонков': 'Количество исходящих звонков внутри сети'})

del telecom_au_out_cc1['index']

telecom_au_out_cc1
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Количество исходящих звонков внутри сети</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166916</td>
      <td>1904</td>
    </tr>
    <tr>
      <th>1</th>
      <td>167150</td>
      <td>1300</td>
    </tr>
    <tr>
      <th>2</th>
      <td>167176</td>
      <td>1135</td>
    </tr>
    <tr>
      <th>3</th>
      <td>167359</td>
      <td>1043</td>
    </tr>
    <tr>
      <th>4</th>
      <td>167497</td>
      <td>940</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>142</th>
      <td>166713</td>
      <td>1</td>
    </tr>
    <tr>
      <th>143</th>
      <td>167009</td>
      <td>1</td>
    </tr>
    <tr>
      <th>144</th>
      <td>166725</td>
      <td>1</td>
    </tr>
    <tr>
      <th>145</th>
      <td>168018</td>
      <td>1</td>
    </tr>
    <tr>
      <th>146</th>
      <td>166691</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>147 rows × 2 columns</p>
</div>



Теперь общее количество исходящих звонков абонентам других операторов:


```python
telecom_cc_false = out_call.query('`Внутренний вызов` == False')
```


```python
telecom_au_out_cc2 = telecom_cc_false.groupby(['id клиента'], as_index = False)['Количество звонков']\
                                     .agg({'Количество звонков':'sum'})\
                                     .sort_values(by = 'Количество звонков', ascending = False)\
                                     .reset_index()
telecom_au_out_cc2 = telecom_au_out_cc2.rename(columns = {'Количество звонков': 'Количество исходящих звонков другим операторам'})

del telecom_au_out_cc2['index']

telecom_au_out_cc2
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Количество исходящих звонков другим операторам</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>65347</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>58426</td>
    </tr>
    <tr>
      <th>2</th>
      <td>168062</td>
      <td>23262</td>
    </tr>
    <tr>
      <th>3</th>
      <td>167125</td>
      <td>14330</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168187</td>
      <td>13333</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>207</th>
      <td>167840</td>
      <td>1</td>
    </tr>
    <tr>
      <th>208</th>
      <td>167906</td>
      <td>1</td>
    </tr>
    <tr>
      <th>209</th>
      <td>167238</td>
      <td>1</td>
    </tr>
    <tr>
      <th>210</th>
      <td>167200</td>
      <td>1</td>
    </tr>
    <tr>
      <th>211</th>
      <td>167144</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>212 rows × 2 columns</p>
</div>



Также необходимо создать ещё две таблицы, со следующей информацией:
1. Общее количество времени разговора исходящих звонков клиента внутри сети;
2. Общее количество времени разговора исходящих звонков абонентам других операторов.

Общее время звонка не учитываем, т.к. время ожидания ответа не учитывается при калькуляции стоимости.

Общее количество времени разговора исходящего звонка клиента внутри сети. Также для удобства расчётов переведём столбцы в минуты c двумя знаками после запятой:


```python
telecom_au_out_cd1 = telecom_cc_true.groupby(['id клиента'], as_index = False)['Длительность разговора']\
                                    .agg({'Длительность разговора':'sum'})\
                                    .sort_values(by = 'Длительность разговора', ascending = False)\
                                    .reset_index()

telecom_au_out_cd1 = telecom_au_out_cd1.rename(columns = {'Длительность разговора': 'Время разговора внутри сети, мин.'})
del telecom_au_out_cd1['index']

minute = 60
telecom_au_out_cd1['Время разговора внутри сети, мин.'] = round(telecom_au_out_cd1['Время разговора внутри сети, мин.']/minute, 2)

telecom_au_out_cd1
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Время разговора внутри сети, мин.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166916</td>
      <td>1512.78</td>
    </tr>
    <tr>
      <th>1</th>
      <td>167497</td>
      <td>1458.12</td>
    </tr>
    <tr>
      <th>2</th>
      <td>167176</td>
      <td>720.03</td>
    </tr>
    <tr>
      <th>3</th>
      <td>167359</td>
      <td>712.85</td>
    </tr>
    <tr>
      <th>4</th>
      <td>167150</td>
      <td>606.67</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>142</th>
      <td>167011</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>143</th>
      <td>166800</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>144</th>
      <td>167487</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>145</th>
      <td>166833</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>146</th>
      <td>167012</td>
      <td>0.00</td>
    </tr>
  </tbody>
</table>
<p>147 rows × 2 columns</p>
</div>



Общее количество времени разговора исходящего звонка абонентам других операторов:


```python
telecom_au_out_cd2 = telecom_cc_false.groupby(['id клиента'], as_index = False)['Длительность разговора']\
                                     .agg({'Длительность разговора':'sum'})\
                                     .sort_values(by = 'Длительность разговора', ascending = False)\
                                     .reset_index()

telecom_au_out_cd2 = telecom_au_out_cd2.rename(columns = {'Длительность разговора': 'Время разговора с абонентами других операторов, мин.'})
del telecom_au_out_cd2['index']

telecom_au_out_cd2['Время разговора с абонентами других операторов, мин.'] = round(telecom_au_out_cd2['Время разговора с абонентами других операторов, мин.']/minute, 2)


telecom_au_out_cd2
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Время разговора с абонентами других операторов, мин.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>168361</td>
      <td>68484.30</td>
    </tr>
    <tr>
      <th>1</th>
      <td>167626</td>
      <td>48912.67</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166658</td>
      <td>32825.28</td>
    </tr>
    <tr>
      <th>3</th>
      <td>167125</td>
      <td>13511.83</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166405</td>
      <td>12839.88</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>207</th>
      <td>167621</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>208</th>
      <td>168008</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>209</th>
      <td>167238</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>210</th>
      <td>166732</td>
      <td>0.00</td>
    </tr>
    <tr>
      <th>211</th>
      <td>167200</td>
      <td>0.00</td>
    </tr>
  </tbody>
</table>
<p>212 rows × 2 columns</p>
</div>



Ещё важно учитывать количество операторов у каждого клиента.

Посмотрим на общее количество операторов:


```python
len(out_call['id оператора'].unique())
```




    874



Отлично. Перед подсчётом количества операторов у каждого клиента необходимо помнить, что у нас там было много пропусков. В связи с этим исключим нашу "заглушку" из подсчёта.


```python
telecom_au_out_oid = out_call.query('`id оператора` != "no information"')
```


```python
telecom_au_out_oid = telecom_au_out_oid.groupby(['id клиента'], as_index = False)['id оператора']\
                                       .agg({'id оператора':'nunique'})\
                                       .sort_values(by = 'id оператора', ascending = False)\
                                       .reset_index()
telecom_au_out_oid = telecom_au_out_oid.rename(columns = {'id оператора': 'Количество операторов у клиента'})

del telecom_au_out_oid['index']

telecom_au_out_oid
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Количество операторов у клиента</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>48</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168187</td>
      <td>42</td>
    </tr>
    <tr>
      <th>2</th>
      <td>167497</td>
      <td>28</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168062</td>
      <td>27</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168361</td>
      <td>27</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>166691</td>
      <td>1</td>
    </tr>
    <tr>
      <th>210</th>
      <td>167530</td>
      <td>1</td>
    </tr>
    <tr>
      <th>211</th>
      <td>166692</td>
      <td>1</td>
    </tr>
    <tr>
      <th>212</th>
      <td>166708</td>
      <td>1</td>
    </tr>
    <tr>
      <th>213</th>
      <td>168606</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 2 columns</p>
</div>



У лидера исследования 48 операторов.

Все необходимые данные для расчёта по каждому клиенту получили. Собираем таблицу из следующих колонок:
1. id клиента;
2. Тарифный план;
3. Количество исходящих звонков внутри сети;
4. Количество исходящих звонков другим операторам;
5. Время разговора внутри сети, мин.;
6. Время разговора с абонентами других операторов, мин.;
7. Количество операторов у клиента.


```python
telecom_au_out = telecom_d_out.merge(telecom_au_out_cc1, on = 'id клиента', how = 'left')
telecom_au_out = telecom_au_out.merge(telecom_au_out_cc2, on = 'id клиента', how = 'left')
telecom_au_out = telecom_au_out.merge(telecom_au_out_cd1, on = 'id клиента', how = 'left')
telecom_au_out = telecom_au_out.merge(telecom_au_out_cd2, on = 'id клиента', how = 'left')
telecom_au_out = telecom_au_out.merge(telecom_au_out_oid, on = 'id клиента', how = 'left')

telecom_au_out
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
      <th>Количество исходящих звонков внутри сети</th>
      <th>Количество исходящих звонков другим операторам</th>
      <th>Время разговора внутри сети, мин.</th>
      <th>Время разговора с абонентами других операторов, мин.</th>
      <th>Количество операторов у клиента</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>B</td>
      <td>55.0</td>
      <td>4898.0</td>
      <td>2.20</td>
      <td>5173.65</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166391</td>
      <td>C</td>
      <td>1.0</td>
      <td>NaN</td>
      <td>0.00</td>
      <td>NaN</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166405</td>
      <td>B</td>
      <td>36.0</td>
      <td>9789.0</td>
      <td>5.10</td>
      <td>12839.88</td>
      <td>10</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166406</td>
      <td>B</td>
      <td>80.0</td>
      <td>7892.0</td>
      <td>21.87</td>
      <td>5055.67</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166407</td>
      <td>A</td>
      <td>539.0</td>
      <td>306.0</td>
      <td>279.03</td>
      <td>317.63</td>
      <td>8</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>168466</td>
      <td>C</td>
      <td>NaN</td>
      <td>966.0</td>
      <td>NaN</td>
      <td>581.00</td>
      <td>2</td>
    </tr>
    <tr>
      <th>210</th>
      <td>168473</td>
      <td>C</td>
      <td>NaN</td>
      <td>22.0</td>
      <td>NaN</td>
      <td>3.95</td>
      <td>1</td>
    </tr>
    <tr>
      <th>211</th>
      <td>168481</td>
      <td>B</td>
      <td>NaN</td>
      <td>20.0</td>
      <td>NaN</td>
      <td>4.67</td>
      <td>3</td>
    </tr>
    <tr>
      <th>212</th>
      <td>168601</td>
      <td>C</td>
      <td>1.0</td>
      <td>586.0</td>
      <td>0.00</td>
      <td>404.40</td>
      <td>2</td>
    </tr>
    <tr>
      <th>213</th>
      <td>168606</td>
      <td>C</td>
      <td>8.0</td>
      <td>8.0</td>
      <td>60.15</td>
      <td>13.43</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 7 columns</p>
</div>



Таблицу составили, но в ней есть пропуски, которые необходимо заполнить для дальнейшей работы.


```python
for col_nan in ['Количество исходящих звонков внутри сети', 'Количество исходящих звонков другим операторам', 'Время разговора внутри сети, мин.', 'Время разговора с абонентами других операторов, мин.']:
    telecom_au_out[col_nan] = telecom_au_out[col_nan].fillna(0)
telecom_au_out
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
      <th>Количество исходящих звонков внутри сети</th>
      <th>Количество исходящих звонков другим операторам</th>
      <th>Время разговора внутри сети, мин.</th>
      <th>Время разговора с абонентами других операторов, мин.</th>
      <th>Количество операторов у клиента</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>B</td>
      <td>55.0</td>
      <td>4898.0</td>
      <td>2.20</td>
      <td>5173.65</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166391</td>
      <td>C</td>
      <td>1.0</td>
      <td>0.0</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166405</td>
      <td>B</td>
      <td>36.0</td>
      <td>9789.0</td>
      <td>5.10</td>
      <td>12839.88</td>
      <td>10</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166406</td>
      <td>B</td>
      <td>80.0</td>
      <td>7892.0</td>
      <td>21.87</td>
      <td>5055.67</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166407</td>
      <td>A</td>
      <td>539.0</td>
      <td>306.0</td>
      <td>279.03</td>
      <td>317.63</td>
      <td>8</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>168466</td>
      <td>C</td>
      <td>0.0</td>
      <td>966.0</td>
      <td>0.00</td>
      <td>581.00</td>
      <td>2</td>
    </tr>
    <tr>
      <th>210</th>
      <td>168473</td>
      <td>C</td>
      <td>0.0</td>
      <td>22.0</td>
      <td>0.00</td>
      <td>3.95</td>
      <td>1</td>
    </tr>
    <tr>
      <th>211</th>
      <td>168481</td>
      <td>B</td>
      <td>0.0</td>
      <td>20.0</td>
      <td>0.00</td>
      <td>4.67</td>
      <td>3</td>
    </tr>
    <tr>
      <th>212</th>
      <td>168601</td>
      <td>C</td>
      <td>1.0</td>
      <td>586.0</td>
      <td>0.00</td>
      <td>404.40</td>
      <td>2</td>
    </tr>
    <tr>
      <th>213</th>
      <td>168606</td>
      <td>C</td>
      <td>8.0</td>
      <td>8.0</td>
      <td>60.15</td>
      <td>13.43</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 7 columns</p>
</div>



Заодно поменять тип у двух колонок на целочисленный:


```python
telecom_au_out['Количество исходящих звонков внутри сети'] = telecom_au_out['Количество исходящих звонков внутри сети'].astype('int')
telecom_au_out['Количество исходящих звонков другим операторам'] = telecom_au_out['Количество исходящих звонков другим операторам'].astype('int')

telecom_au_out.sort_values(by = 'Время разговора с абонентами других операторов, мин.', ascending = False)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
      <th>Количество исходящих звонков внутри сети</th>
      <th>Количество исходящих звонков другим операторам</th>
      <th>Время разговора внутри сети, мин.</th>
      <th>Время разговора с абонентами других операторов, мин.</th>
      <th>Количество операторов у клиента</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>206</th>
      <td>168361</td>
      <td>A</td>
      <td>58</td>
      <td>58426</td>
      <td>0.28</td>
      <td>68484.30</td>
      <td>27</td>
    </tr>
    <tr>
      <th>131</th>
      <td>167626</td>
      <td>A</td>
      <td>13</td>
      <td>65347</td>
      <td>0.00</td>
      <td>48912.67</td>
      <td>48</td>
    </tr>
    <tr>
      <th>19</th>
      <td>166658</td>
      <td>B</td>
      <td>18</td>
      <td>10453</td>
      <td>0.00</td>
      <td>32825.28</td>
      <td>16</td>
    </tr>
    <tr>
      <th>81</th>
      <td>167125</td>
      <td>C</td>
      <td>125</td>
      <td>14330</td>
      <td>0.00</td>
      <td>13511.83</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166405</td>
      <td>B</td>
      <td>36</td>
      <td>9789</td>
      <td>5.10</td>
      <td>12839.88</td>
      <td>10</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166391</td>
      <td>C</td>
      <td>1</td>
      <td>0</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
    </tr>
    <tr>
      <th>173</th>
      <td>168008</td>
      <td>C</td>
      <td>0</td>
      <td>5</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
    </tr>
    <tr>
      <th>108</th>
      <td>167412</td>
      <td>C</td>
      <td>1</td>
      <td>0</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
    </tr>
    <tr>
      <th>148</th>
      <td>167805</td>
      <td>C</td>
      <td>0</td>
      <td>16</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
    </tr>
    <tr>
      <th>202</th>
      <td>168291</td>
      <td>B</td>
      <td>3</td>
      <td>13</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 7 columns</p>
</div>



Всё. Таблица готова. Теперь можно переходить к анализу тарифных планов абонентов.

**Важно!**

Сложность анализа заключается в том, что мы имеем "на руках" данные за 118 дней. Эта практически 4 месяца. Количество звонков непостоянно по месяцам. Тарифный план у нас рассчитан на 1 месяц. Брать за эталон самый "активный" месяц и его рассмотреть для презентации в принципе можно, т.к. там показатели звонков очень высоки и это будет прекрасный маркетинговый ход и аргумент для перехода на другой тариф для финансового директора, но он может запросить данные по остальным месяцам, которые нам предоставили, а там не так всё хорошо.

Поэтому предлагаю 118 дней округлить до 4 месяцев, а тарифные планы посчитать сразу за весь период. 3-4 оставшихся дня не будем учитывать, т.к. они сильно не изменят результат. Зато у нас будет полная картина по всему периоду. Если необходимо, то пусть отдел маркетинга ставит задачи по аналитике по месяцам, но если дробить и сравнивать тот же самый август и ноябрь, то на этом фоне лучше смотреть на общую картину, т.к. низкие параметры могут спугнуть финансового директора. Ну и "давить" на долгосрочную перспективу.

#### Анализ тарифного плана

Для начала определим какой тарифный план лидирует по количеству клиентов.


```python
tariff_plan = ['Тарифный план']

tariff_plan_A = telecom_au_out[telecom_au_out['Тарифный план'] == 'A']
tariff_plan_B = telecom_au_out[telecom_au_out['Тарифный план'] == 'B']
tariff_plan_C = telecom_au_out[telecom_au_out['Тарифный план'] == 'C']

plt.figure(figsize = (18,9))
plt.title('Распределение активных пользователей в тарифном плане', fontsize = 16)
for column in tariff_plan:
#   plt.text('A', 20, tariff_plan_A, ha = 'center') # пытался вписать в столбик инф-цию о количестве
#   plt.text('B', 70, tariff_plan_A, ha = 'center') # клиентов в тарифе по отдельности, но пока не
#   plt.text('C', 90, tariff_plan_A, ha = 'center') # нашёл необходимую команду.
    plt.hist(tariff_plan_A[column], bins = 5, label = 'Тарифный план А')
    plt.hist(tariff_plan_B[column], bins = 5, label = 'Тарифный план B')
    plt.hist(tariff_plan_C[column], bins = 5, label = 'Тарифный план C')
    plt.xticks(rotation = 0)
    plt.ylabel('Количество активных клиентов', fontsize = 14)
    plt.xlabel('Тарифные планы', fontsize = 14)
    yaxis = {'categoryorder':'total ascending'},
    plt.legend()
```


    
![png](output_246_0.png)
    


Посмотрим на это в цифрах:


```python
print('Количество клиентов на тарифном плане А:', len(tariff_plan_A))
print('Количество клиентов на тарифном плане B:', len(tariff_plan_B))
print('Количество клиентов на тарифном плане C:', len(tariff_plan_C))
```

    Количество клиентов на тарифном плане А: 26
    Количество клиентов на тарифном плане B: 85
    Количество клиентов на тарифном плане C: 103


Как мы заметили по графику и в цифрах: наибольшее количество клиентов пользуются тарифным планом С.

Теперь займёмся экономикой. Создадим таблицу со всей информацией по тарифам:


```python
tariff_plans = pd.DataFrame(
    {'Тарифный план': ['A', 'B', 'C'],
     'Ежемесячная плата, руб.': [4000, 2000, 1000],
     'Дополнительная ежемесячная плата, руб.': [50, 150, 300],
     'Исходящие звонки внутри сети, мин.': [2000, 500, 0],
     'Цена сверх лимита, руб/мин.': [0.1, 0.15, 0.3], 
     'Исходящие звонки, руб/мин.': [0.3, 0.5, 0.7]}
)
tariff_plans
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Тарифный план</th>
      <th>Ежемесячная плата, руб.</th>
      <th>Дополнительная ежемесячная плата, руб.</th>
      <th>Исходящие звонки внутри сети, мин.</th>
      <th>Цена сверх лимита, руб/мин.</th>
      <th>Исходящие звонки, руб/мин.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>4000</td>
      <td>50</td>
      <td>2000</td>
      <td>0.10</td>
      <td>0.3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>B</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>C</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
    </tr>
  </tbody>
</table>
</div>



Таблицу с информацией по тарифам создали. Теперь добавим её к ранее созданной таблице с активными клиентами.


```python
telecom_au_out = telecom_au_out.merge(tariff_plans, on = 'Тарифный план', how = 'left')
telecom_au_out
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
      <th>Количество исходящих звонков внутри сети</th>
      <th>Количество исходящих звонков другим операторам</th>
      <th>Время разговора внутри сети, мин.</th>
      <th>Время разговора с абонентами других операторов, мин.</th>
      <th>Количество операторов у клиента</th>
      <th>Ежемесячная плата, руб.</th>
      <th>Дополнительная ежемесячная плата, руб.</th>
      <th>Исходящие звонки внутри сети, мин.</th>
      <th>Цена сверх лимита, руб/мин.</th>
      <th>Исходящие звонки, руб/мин.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>B</td>
      <td>55</td>
      <td>4898</td>
      <td>2.20</td>
      <td>5173.65</td>
      <td>5</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166391</td>
      <td>C</td>
      <td>1</td>
      <td>0</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166405</td>
      <td>B</td>
      <td>36</td>
      <td>9789</td>
      <td>5.10</td>
      <td>12839.88</td>
      <td>10</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166406</td>
      <td>B</td>
      <td>80</td>
      <td>7892</td>
      <td>21.87</td>
      <td>5055.67</td>
      <td>3</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166407</td>
      <td>A</td>
      <td>539</td>
      <td>306</td>
      <td>279.03</td>
      <td>317.63</td>
      <td>8</td>
      <td>4000</td>
      <td>50</td>
      <td>2000</td>
      <td>0.10</td>
      <td>0.3</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>168466</td>
      <td>C</td>
      <td>0</td>
      <td>966</td>
      <td>0.00</td>
      <td>581.00</td>
      <td>2</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
    </tr>
    <tr>
      <th>210</th>
      <td>168473</td>
      <td>C</td>
      <td>0</td>
      <td>22</td>
      <td>0.00</td>
      <td>3.95</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
    </tr>
    <tr>
      <th>211</th>
      <td>168481</td>
      <td>B</td>
      <td>0</td>
      <td>20</td>
      <td>0.00</td>
      <td>4.67</td>
      <td>3</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>212</th>
      <td>168601</td>
      <td>C</td>
      <td>1</td>
      <td>586</td>
      <td>0.00</td>
      <td>404.40</td>
      <td>2</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
    </tr>
    <tr>
      <th>213</th>
      <td>168606</td>
      <td>C</td>
      <td>8</td>
      <td>8</td>
      <td>60.15</td>
      <td>13.43</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 12 columns</p>
</div>



Необходимо добавить ещё одну колонку для определения количества минут сверх лимита внутри сети. Надо также учитывать, что мы делаем расчёт за весь период, т.е. за 4 месяца. В связи с этим создадим переменную с количеством месяцев расчётного периода.


```python
calc_period = 4
```

Составим функцию для расчёта количества минут сверх лимита:


```python
def limit(row):
    if row['Количество исходящих звонков внутри сети'] >= row['Исходящие звонки внутри сети, мин.']*calc_period:
        diff = row['Количество исходящих звонков внутри сети'] - row['Исходящие звонки внутри сети, мин.']*calc_period            
    else:
        diff = 0
    return diff

telecom_au_out['Количество минут сверх лимита'] = telecom_au_out.apply(limit, axis=1)

telecom_au_out
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Тарифный план</th>
      <th>Количество исходящих звонков внутри сети</th>
      <th>Количество исходящих звонков другим операторам</th>
      <th>Время разговора внутри сети, мин.</th>
      <th>Время разговора с абонентами других операторов, мин.</th>
      <th>Количество операторов у клиента</th>
      <th>Ежемесячная плата, руб.</th>
      <th>Дополнительная ежемесячная плата, руб.</th>
      <th>Исходящие звонки внутри сети, мин.</th>
      <th>Цена сверх лимита, руб/мин.</th>
      <th>Исходящие звонки, руб/мин.</th>
      <th>Количество минут сверх лимита</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166377</td>
      <td>B</td>
      <td>55</td>
      <td>4898</td>
      <td>2.20</td>
      <td>5173.65</td>
      <td>5</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166391</td>
      <td>C</td>
      <td>1</td>
      <td>0</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166405</td>
      <td>B</td>
      <td>36</td>
      <td>9789</td>
      <td>5.10</td>
      <td>12839.88</td>
      <td>10</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166406</td>
      <td>B</td>
      <td>80</td>
      <td>7892</td>
      <td>21.87</td>
      <td>5055.67</td>
      <td>3</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>166407</td>
      <td>A</td>
      <td>539</td>
      <td>306</td>
      <td>279.03</td>
      <td>317.63</td>
      <td>8</td>
      <td>4000</td>
      <td>50</td>
      <td>2000</td>
      <td>0.10</td>
      <td>0.3</td>
      <td>0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>168466</td>
      <td>C</td>
      <td>0</td>
      <td>966</td>
      <td>0.00</td>
      <td>581.00</td>
      <td>2</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
      <td>0</td>
    </tr>
    <tr>
      <th>210</th>
      <td>168473</td>
      <td>C</td>
      <td>0</td>
      <td>22</td>
      <td>0.00</td>
      <td>3.95</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
      <td>0</td>
    </tr>
    <tr>
      <th>211</th>
      <td>168481</td>
      <td>B</td>
      <td>0</td>
      <td>20</td>
      <td>0.00</td>
      <td>4.67</td>
      <td>3</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
      <td>0</td>
    </tr>
    <tr>
      <th>212</th>
      <td>168601</td>
      <td>C</td>
      <td>1</td>
      <td>586</td>
      <td>0.00</td>
      <td>404.40</td>
      <td>2</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
      <td>1</td>
    </tr>
    <tr>
      <th>213</th>
      <td>168606</td>
      <td>C</td>
      <td>8</td>
      <td>8</td>
      <td>60.15</td>
      <td>13.43</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 13 columns</p>
</div>



Отлично. Теперь можем приступать к расчёту текущей платы клиентов по тарифам. Результат добавим в новый столбец.


```python
telecom_au_out['Плата по текущему тарифному плану за период, руб.'] = telecom_au_out['Ежемесячная плата, руб.']*calc_period +\
    (telecom_au_out['Дополнительная ежемесячная плата, руб.']*calc_period)*telecom_au_out['Количество операторов у клиента'] +\
    telecom_au_out['Цена сверх лимита, руб/мин.']*telecom_au_out['Количество минут сверх лимита'] +\
    telecom_au_out['Количество исходящих звонков другим операторам']* telecom_au_out['Исходящие звонки, руб/мин.']

telecom_au_out = telecom_au_out.sort_values(by = 'Плата по текущему тарифному плану за период, руб.', ascending = False).reset_index()
telecom_au_out
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>id клиента</th>
      <th>Тарифный план</th>
      <th>Количество исходящих звонков внутри сети</th>
      <th>Количество исходящих звонков другим операторам</th>
      <th>Время разговора внутри сети, мин.</th>
      <th>Время разговора с абонентами других операторов, мин.</th>
      <th>Количество операторов у клиента</th>
      <th>Ежемесячная плата, руб.</th>
      <th>Дополнительная ежемесячная плата, руб.</th>
      <th>Исходящие звонки внутри сети, мин.</th>
      <th>Цена сверх лимита, руб/мин.</th>
      <th>Исходящие звонки, руб/мин.</th>
      <th>Количество минут сверх лимита</th>
      <th>Плата по текущему тарифному плану за период, руб.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>131</td>
      <td>167626</td>
      <td>A</td>
      <td>13</td>
      <td>65347</td>
      <td>0.00</td>
      <td>48912.67</td>
      <td>48</td>
      <td>4000</td>
      <td>50</td>
      <td>2000</td>
      <td>0.1</td>
      <td>0.3</td>
      <td>0</td>
      <td>45204.1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>206</td>
      <td>168361</td>
      <td>A</td>
      <td>58</td>
      <td>58426</td>
      <td>0.28</td>
      <td>68484.30</td>
      <td>27</td>
      <td>4000</td>
      <td>50</td>
      <td>2000</td>
      <td>0.1</td>
      <td>0.3</td>
      <td>0</td>
      <td>38927.8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>166520</td>
      <td>C</td>
      <td>15</td>
      <td>5959</td>
      <td>3.68</td>
      <td>4005.32</td>
      <td>18</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.3</td>
      <td>0.7</td>
      <td>15</td>
      <td>29775.8</td>
    </tr>
    <tr>
      <th>3</th>
      <td>193</td>
      <td>168187</td>
      <td>A</td>
      <td>111</td>
      <td>13333</td>
      <td>97.88</td>
      <td>8929.63</td>
      <td>42</td>
      <td>4000</td>
      <td>50</td>
      <td>2000</td>
      <td>0.1</td>
      <td>0.3</td>
      <td>0</td>
      <td>28399.9</td>
    </tr>
    <tr>
      <th>4</th>
      <td>179</td>
      <td>168062</td>
      <td>A</td>
      <td>625</td>
      <td>23262</td>
      <td>445.18</td>
      <td>9058.40</td>
      <td>27</td>
      <td>4000</td>
      <td>50</td>
      <td>2000</td>
      <td>0.1</td>
      <td>0.3</td>
      <td>0</td>
      <td>28378.6</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>129</td>
      <td>167599</td>
      <td>C</td>
      <td>0</td>
      <td>1</td>
      <td>0.00</td>
      <td>0.67</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.3</td>
      <td>0.7</td>
      <td>0</td>
      <td>5200.7</td>
    </tr>
    <tr>
      <th>210</th>
      <td>97</td>
      <td>167238</td>
      <td>C</td>
      <td>0</td>
      <td>1</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.3</td>
      <td>0.7</td>
      <td>0</td>
      <td>5200.7</td>
    </tr>
    <tr>
      <th>211</th>
      <td>95</td>
      <td>167200</td>
      <td>C</td>
      <td>0</td>
      <td>1</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.3</td>
      <td>0.7</td>
      <td>0</td>
      <td>5200.7</td>
    </tr>
    <tr>
      <th>212</th>
      <td>108</td>
      <td>167412</td>
      <td>C</td>
      <td>1</td>
      <td>0</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.3</td>
      <td>0.7</td>
      <td>1</td>
      <td>5200.3</td>
    </tr>
    <tr>
      <th>213</th>
      <td>1</td>
      <td>166391</td>
      <td>C</td>
      <td>1</td>
      <td>0</td>
      <td>0.00</td>
      <td>0.00</td>
      <td>1</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.3</td>
      <td>0.7</td>
      <td>1</td>
      <td>5200.3</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 15 columns</p>
</div>



Сделано. Создадим новую таблицу, в которой отобразим необходимую для дальнейшего анализа информацию.


```python
telecom_payment = telecom_au_out[['id клиента', 'Тарифный план', 'Плата по текущему тарифному плану за период, руб.']]
telecom_payment = telecom_payment.rename(columns = {'Тарифный план': 'Текущий тарифный план'})

telecom_payment
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Текущий тарифный план</th>
      <th>Плата по текущему тарифному плану за период, руб.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>A</td>
      <td>45204.1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>A</td>
      <td>38927.8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166520</td>
      <td>C</td>
      <td>29775.8</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168187</td>
      <td>A</td>
      <td>28399.9</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168062</td>
      <td>A</td>
      <td>28378.6</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>167599</td>
      <td>C</td>
      <td>5200.7</td>
    </tr>
    <tr>
      <th>210</th>
      <td>167238</td>
      <td>C</td>
      <td>5200.7</td>
    </tr>
    <tr>
      <th>211</th>
      <td>167200</td>
      <td>C</td>
      <td>5200.7</td>
    </tr>
    <tr>
      <th>212</th>
      <td>167412</td>
      <td>C</td>
      <td>5200.3</td>
    </tr>
    <tr>
      <th>213</th>
      <td>166391</td>
      <td>C</td>
      <td>5200.3</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 3 columns</p>
</div>



Пока трудно оценить насколько завышена плата по тарифам. Необходимо проанализировать плату по другим тарифам, в случае если клиенты перешли бы на них. 

Вновь отобразим таблицу с тарифными планами:


```python
tariff_plans
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Тарифный план</th>
      <th>Ежемесячная плата, руб.</th>
      <th>Дополнительная ежемесячная плата, руб.</th>
      <th>Исходящие звонки внутри сети, мин.</th>
      <th>Цена сверх лимита, руб/мин.</th>
      <th>Исходящие звонки, руб/мин.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>4000</td>
      <td>50</td>
      <td>2000</td>
      <td>0.10</td>
      <td>0.3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>B</td>
      <td>2000</td>
      <td>150</td>
      <td>500</td>
      <td>0.15</td>
      <td>0.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>C</td>
      <td>1000</td>
      <td>300</td>
      <td>0</td>
      <td>0.30</td>
      <td>0.7</td>
    </tr>
  </tbody>
</table>
</div>



Добавим в таблицу колонки, в которых будет указана возможная плата клиента при условии использования того или иного тарифа.


```python
telecom_payment['Плата по тарифу A, руб.'] = tariff_plans.loc[0, 'Ежемесячная плата, руб.'] * calc_period +\
           tariff_plans.loc[0, 'Дополнительная ежемесячная плата, руб.'] * calc_period * telecom_au_out['Количество операторов у клиента'] +\
           tariff_plans.loc[0, 'Цена сверх лимита, руб/мин.'] * telecom_au_out['Количество минут сверх лимита'] +\
           tariff_plans.loc[0, 'Исходящие звонки, руб/мин.'] * telecom_au_out['Количество исходящих звонков другим операторам']

telecom_payment['Плата по тарифу B, руб.'] = tariff_plans.loc[1, 'Ежемесячная плата, руб.'] * calc_period +\
           tariff_plans.loc[1, 'Дополнительная ежемесячная плата, руб.'] * calc_period * telecom_au_out['Количество операторов у клиента'] +\
           tariff_plans.loc[1, 'Цена сверх лимита, руб/мин.'] * (telecom_au_out['Количество минут сверх лимита']) +\
           tariff_plans.loc[1, 'Исходящие звонки, руб/мин.'] * telecom_au_out['Количество исходящих звонков другим операторам']

telecom_payment['Плата по тарифу C, руб.'] = tariff_plans.loc[2, 'Ежемесячная плата, руб.'] * calc_period +\
           tariff_plans.loc[2, 'Дополнительная ежемесячная плата, руб.'] * calc_period * telecom_au_out['Количество операторов у клиента'] +\
           tariff_plans.loc[2, 'Цена сверх лимита, руб/мин.'] * telecom_au_out['Количество минут сверх лимита'] +\
           tariff_plans.loc[2, 'Исходящие звонки, руб/мин.'] * telecom_au_out['Количество исходящих звонков другим операторам']

telecom_payment
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Текущий тарифный план</th>
      <th>Плата по текущему тарифному плану за период, руб.</th>
      <th>Плата по тарифу A, руб.</th>
      <th>Плата по тарифу B, руб.</th>
      <th>Плата по тарифу C, руб.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>A</td>
      <td>45204.1</td>
      <td>45204.1</td>
      <td>69473.50</td>
      <td>107342.9</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>A</td>
      <td>38927.8</td>
      <td>38927.8</td>
      <td>53413.00</td>
      <td>77298.2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166520</td>
      <td>C</td>
      <td>29775.8</td>
      <td>21389.2</td>
      <td>21781.75</td>
      <td>29775.8</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168187</td>
      <td>A</td>
      <td>28399.9</td>
      <td>28399.9</td>
      <td>39866.50</td>
      <td>63733.1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168062</td>
      <td>A</td>
      <td>28378.6</td>
      <td>28378.6</td>
      <td>35831.00</td>
      <td>52683.4</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>167599</td>
      <td>C</td>
      <td>5200.7</td>
      <td>16200.3</td>
      <td>8600.50</td>
      <td>5200.7</td>
    </tr>
    <tr>
      <th>210</th>
      <td>167238</td>
      <td>C</td>
      <td>5200.7</td>
      <td>16200.3</td>
      <td>8600.50</td>
      <td>5200.7</td>
    </tr>
    <tr>
      <th>211</th>
      <td>167200</td>
      <td>C</td>
      <td>5200.7</td>
      <td>16200.3</td>
      <td>8600.50</td>
      <td>5200.7</td>
    </tr>
    <tr>
      <th>212</th>
      <td>167412</td>
      <td>C</td>
      <td>5200.3</td>
      <td>16200.1</td>
      <td>8600.15</td>
      <td>5200.3</td>
    </tr>
    <tr>
      <th>213</th>
      <td>166391</td>
      <td>C</td>
      <td>5200.3</td>
      <td>16200.1</td>
      <td>8600.15</td>
      <td>5200.3</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 6 columns</p>
</div>



Составим функцию по нахождению самого выгодного тарифа и добавим результат в отдельную колонку.


```python
def minimum_fee(row):
    if row['Плата по тарифу A, руб.'] < row['Плата по тарифу B, руб.'] and row['Плата по тарифу A, руб.'] < row['Плата по тарифу C, руб.']:
        diff = 'A'
    elif row['Плата по тарифу B, руб.'] < row['Плата по тарифу A, руб.'] and row['Плата по тарифу B, руб.'] < row['Плата по тарифу C, руб.']:
        diff = 'B'
    else: 
        diff = 'C'
    return diff

telecom_payment['Самый выгодный тариф'] = telecom_payment.apply(minimum_fee, axis = 1)

telecom_payment
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Текущий тарифный план</th>
      <th>Плата по текущему тарифному плану за период, руб.</th>
      <th>Плата по тарифу A, руб.</th>
      <th>Плата по тарифу B, руб.</th>
      <th>Плата по тарифу C, руб.</th>
      <th>Самый выгодный тариф</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>A</td>
      <td>45204.1</td>
      <td>45204.1</td>
      <td>69473.50</td>
      <td>107342.9</td>
      <td>A</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>A</td>
      <td>38927.8</td>
      <td>38927.8</td>
      <td>53413.00</td>
      <td>77298.2</td>
      <td>A</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166520</td>
      <td>C</td>
      <td>29775.8</td>
      <td>21389.2</td>
      <td>21781.75</td>
      <td>29775.8</td>
      <td>A</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168187</td>
      <td>A</td>
      <td>28399.9</td>
      <td>28399.9</td>
      <td>39866.50</td>
      <td>63733.1</td>
      <td>A</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168062</td>
      <td>A</td>
      <td>28378.6</td>
      <td>28378.6</td>
      <td>35831.00</td>
      <td>52683.4</td>
      <td>A</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>209</th>
      <td>167599</td>
      <td>C</td>
      <td>5200.7</td>
      <td>16200.3</td>
      <td>8600.50</td>
      <td>5200.7</td>
      <td>C</td>
    </tr>
    <tr>
      <th>210</th>
      <td>167238</td>
      <td>C</td>
      <td>5200.7</td>
      <td>16200.3</td>
      <td>8600.50</td>
      <td>5200.7</td>
      <td>C</td>
    </tr>
    <tr>
      <th>211</th>
      <td>167200</td>
      <td>C</td>
      <td>5200.7</td>
      <td>16200.3</td>
      <td>8600.50</td>
      <td>5200.7</td>
      <td>C</td>
    </tr>
    <tr>
      <th>212</th>
      <td>167412</td>
      <td>C</td>
      <td>5200.3</td>
      <td>16200.1</td>
      <td>8600.15</td>
      <td>5200.3</td>
      <td>C</td>
    </tr>
    <tr>
      <th>213</th>
      <td>166391</td>
      <td>C</td>
      <td>5200.3</td>
      <td>16200.1</td>
      <td>8600.15</td>
      <td>5200.3</td>
      <td>C</td>
    </tr>
  </tbody>
</table>
<p>214 rows × 7 columns</p>
</div>



Оставим в таблице только тех клиентов, у которых самых выгодный тариф отличается.


```python
prospective_clients = telecom_payment.query('`Текущий тарифный план` != `Самый выгодный тариф`').reset_index()
```

Найдём возможную выгоду при переходе на другой тариф для каждого клиента.


```python
def benefit(row):
    if row['Плата по тарифу A, руб.'] < row['Плата по тарифу B, руб.'] and row['Плата по тарифу A, руб.'] < row['Плата по тарифу C, руб.']:
        diff = row['Плата по текущему тарифному плану за период, руб.'] - row['Плата по тарифу A, руб.']
    elif row['Плата по тарифу B, руб.'] < row['Плата по тарифу A, руб.'] and row['Плата по тарифу B, руб.'] < row['Плата по тарифу C, руб.']:
        diff = row['Плата по текущему тарифному плану за период, руб.'] - row['Плата по тарифу B, руб.']
    else: 
        diff = row['Плата по текущему тарифному плану за период, руб.'] - row['Плата по тарифу C, руб.']
    return diff

prospective_clients['Выгода, руб.'] = prospective_clients.apply(benefit, axis = 1)

del prospective_clients['index']

prospective_clients
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Текущий тарифный план</th>
      <th>Плата по текущему тарифному плану за период, руб.</th>
      <th>Плата по тарифу A, руб.</th>
      <th>Плата по тарифу B, руб.</th>
      <th>Плата по тарифу C, руб.</th>
      <th>Самый выгодный тариф</th>
      <th>Выгода, руб.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>166520</td>
      <td>C</td>
      <td>29775.8</td>
      <td>21389.2</td>
      <td>21781.75</td>
      <td>29775.8</td>
      <td>A</td>
      <td>8386.60</td>
    </tr>
    <tr>
      <th>1</th>
      <td>167125</td>
      <td>C</td>
      <td>23668.5</td>
      <td>21911.5</td>
      <td>19983.75</td>
      <td>23668.5</td>
      <td>B</td>
      <td>3684.75</td>
    </tr>
    <tr>
      <th>2</th>
      <td>166680</td>
      <td>B</td>
      <td>23083.0</td>
      <td>21689.8</td>
      <td>23083.00</td>
      <td>32676.2</td>
      <td>A</td>
      <td>1393.20</td>
    </tr>
    <tr>
      <th>3</th>
      <td>166658</td>
      <td>B</td>
      <td>22826.5</td>
      <td>22335.9</td>
      <td>22826.50</td>
      <td>30517.1</td>
      <td>A</td>
      <td>490.60</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168336</td>
      <td>C</td>
      <td>21087.4</td>
      <td>19233.8</td>
      <td>16854.20</td>
      <td>21087.4</td>
      <td>B</td>
      <td>4233.20</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>100</th>
      <td>167543</td>
      <td>B</td>
      <td>8604.5</td>
      <td>16202.7</td>
      <td>8604.50</td>
      <td>5206.3</td>
      <td>C</td>
      <td>3398.20</td>
    </tr>
    <tr>
      <th>101</th>
      <td>167263</td>
      <td>B</td>
      <td>8603.5</td>
      <td>16202.1</td>
      <td>8603.50</td>
      <td>5204.9</td>
      <td>C</td>
      <td>3398.60</td>
    </tr>
    <tr>
      <th>102</th>
      <td>167621</td>
      <td>B</td>
      <td>8601.5</td>
      <td>16200.9</td>
      <td>8601.50</td>
      <td>5202.1</td>
      <td>C</td>
      <td>3399.40</td>
    </tr>
    <tr>
      <th>103</th>
      <td>167288</td>
      <td>B</td>
      <td>8601.0</td>
      <td>16200.6</td>
      <td>8601.00</td>
      <td>5201.4</td>
      <td>C</td>
      <td>3399.60</td>
    </tr>
    <tr>
      <th>104</th>
      <td>167840</td>
      <td>B</td>
      <td>8600.5</td>
      <td>16200.3</td>
      <td>8600.50</td>
      <td>5200.7</td>
      <td>C</td>
      <td>3399.80</td>
    </tr>
  </tbody>
</table>
<p>105 rows × 8 columns</p>
</div>



Составим список тех, кому рекомендовано перейти на другой тариф и какую выгоду они могут получит. Данный список я бы передал дальше в отдел маркетинга для дальнейшей проработки клиентов.


```python
prospective_clients = prospective_clients[['id клиента', 'Текущий тарифный план', 'Самый выгодный тариф', 'Выгода, руб.']]
prospective_clients = prospective_clients.rename(columns = {'Самый выгодный тариф': 'Рекомендуемый тариф'}).reset_index()
prospective_clients = prospective_clients.sort_values(by = 'Выгода, руб.', ascending = False)

del prospective_clients['index']

prospective_clients
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Текущий тарифный план</th>
      <th>Рекомендуемый тариф</th>
      <th>Выгода, руб.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>26</th>
      <td>168128</td>
      <td>A</td>
      <td>C</td>
      <td>10963.60</td>
    </tr>
    <tr>
      <th>25</th>
      <td>167285</td>
      <td>A</td>
      <td>C</td>
      <td>10912.40</td>
    </tr>
    <tr>
      <th>23</th>
      <td>167634</td>
      <td>A</td>
      <td>C</td>
      <td>10709.20</td>
    </tr>
    <tr>
      <th>21</th>
      <td>168253</td>
      <td>A</td>
      <td>C</td>
      <td>10541.60</td>
    </tr>
    <tr>
      <th>20</th>
      <td>167799</td>
      <td>A</td>
      <td>C</td>
      <td>10527.20</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>30</th>
      <td>166997</td>
      <td>C</td>
      <td>B</td>
      <td>299.60</td>
    </tr>
    <tr>
      <th>35</th>
      <td>167172</td>
      <td>B</td>
      <td>C</td>
      <td>298.00</td>
    </tr>
    <tr>
      <th>34</th>
      <td>166939</td>
      <td>C</td>
      <td>B</td>
      <td>220.30</td>
    </tr>
    <tr>
      <th>32</th>
      <td>167011</td>
      <td>C</td>
      <td>B</td>
      <td>200.45</td>
    </tr>
    <tr>
      <th>31</th>
      <td>166377</td>
      <td>B</td>
      <td>C</td>
      <td>20.40</td>
    </tr>
  </tbody>
</table>
<p>105 rows × 4 columns</p>
</div>



Наибольшую выгоду при смене тарифа будут иметь следующие клиенты.


```python
benefits_company = prospective_clients.query('`Текущий тарифный план` == "A" and `Рекомендуемый тариф` == "C"').reset_index()
del benefits_company['index']
benefits_company
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Текущий тарифный план</th>
      <th>Рекомендуемый тариф</th>
      <th>Выгода, руб.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>168128</td>
      <td>A</td>
      <td>C</td>
      <td>10963.6</td>
    </tr>
    <tr>
      <th>1</th>
      <td>167285</td>
      <td>A</td>
      <td>C</td>
      <td>10912.4</td>
    </tr>
    <tr>
      <th>2</th>
      <td>167634</td>
      <td>A</td>
      <td>C</td>
      <td>10709.2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168253</td>
      <td>A</td>
      <td>C</td>
      <td>10541.6</td>
    </tr>
    <tr>
      <th>4</th>
      <td>167799</td>
      <td>A</td>
      <td>C</td>
      <td>10527.2</td>
    </tr>
    <tr>
      <th>5</th>
      <td>166725</td>
      <td>A</td>
      <td>C</td>
      <td>10517.2</td>
    </tr>
    <tr>
      <th>6</th>
      <td>166713</td>
      <td>A</td>
      <td>C</td>
      <td>9996.4</td>
    </tr>
    <tr>
      <th>7</th>
      <td>168295</td>
      <td>A</td>
      <td>C</td>
      <td>9945.6</td>
    </tr>
    <tr>
      <th>8</th>
      <td>166541</td>
      <td>A</td>
      <td>C</td>
      <td>8915.2</td>
    </tr>
    <tr>
      <th>9</th>
      <td>167185</td>
      <td>A</td>
      <td>C</td>
      <td>8786.8</td>
    </tr>
    <tr>
      <th>10</th>
      <td>167949</td>
      <td>A</td>
      <td>C</td>
      <td>8702.4</td>
    </tr>
    <tr>
      <th>11</th>
      <td>166843</td>
      <td>A</td>
      <td>C</td>
      <td>7908.8</td>
    </tr>
    <tr>
      <th>12</th>
      <td>166609</td>
      <td>A</td>
      <td>C</td>
      <td>6940.0</td>
    </tr>
    <tr>
      <th>13</th>
      <td>168121</td>
      <td>A</td>
      <td>C</td>
      <td>6925.6</td>
    </tr>
    <tr>
      <th>14</th>
      <td>166901</td>
      <td>A</td>
      <td>C</td>
      <td>6923.6</td>
    </tr>
    <tr>
      <th>15</th>
      <td>166582</td>
      <td>A</td>
      <td>C</td>
      <td>6477.2</td>
    </tr>
    <tr>
      <th>16</th>
      <td>168193</td>
      <td>A</td>
      <td>C</td>
      <td>5955.2</td>
    </tr>
  </tbody>
</table>
</div>



С одной стороны такая большая выгода будет иметь для клиента большой интерес, но с другой - потеря денег компании "Нупозвони" из-за такого резкого "скачка". Я бы порекомендовал отделу маркетинга проработать вопрос о "ступенчатом" предложение смене тарифа, т.е. сначала предложить переход на тариф "B". Если отказ, то уже переход на тариф "С".

Аналогично можно поступить с теми, кто только принимает звонки. Некоторые из них находятся на тарифе A и можно им предложить не переходить сразу на тариф C, а пока перейти на тариф B, но это уже отдел маркетинга знает как лучше нужно поступить.

*P.S. возможно посещения семинаров Максима Батырева и чтение его книг были не бесполезны)*

#### Вывод

И так. Мы имеем список их 18 клиентов, которые работают только "на входящих" звонках и при этом используют более дорогой тариф. Им рекомендован переход на тариф С.

Также мы получили список из 105 клиентов, которые используют менее выгодный тариф, чем они сейчас имеют. В том числе были добавлены колонки, в которых отображена информация по рекомендуемому тарифу, а также по возможной выгоде, который они могли получить на весь период (4 месяца).

Из этой таблицы выделена дополнительная таблица, в которой составлен список тех, кто "перепригивает" через тариф. По-моему мнению, данные клиенты являются самыми перспективными для проработки.

### Вывод

Был проведён исследовательский анализ по поиску клиентов с неоптимальными тарифами провайдера "Нупозвони". В результате исследовательского анализа выяснил следующее:
1. Наиболее активными клиентами являются 271 компания;
2. Входящих звонков 40,92 % от общего количества. Исходящих - 59.08 %. Наблюдаются спады звонков в выходные дни;
3. Пропущенных звонков 43,6 % от общего количества. Принятых - 56,4 %. Спады также наблюдаются в выходные;
4. Процент звонков внутри сети 11,92 %. Процент звонков с клиентами других операторов - 88,08 %;
5. Заметный рост количества звонков к концу расчётного периода;
6. Регистрация на сервисе распределена равномерно по всему периоду;
7. Общее количество звонков (входящие и исходящие) у "лидера" рейтинга - 68543;
8. Наибольшее количество операторов у клиента 167626 - 48;
9. 214 клиентов совершали и исходящие и входящие звонки. 57 клиентов только принимали звонки;
10. Среди 57 клиентов, которые только принимали звонки, есть 18 клентов, кому можно предложить перейти на более выгодный тариф;
11. Наиболее популярный тариф среди клиентов тариф С - 103 клиента. Тариф В имеет - 85 клиентов, тариф А - 26.
12. Составлены списки, в которых отображены клиенты, рекомендуемые к переходу на другой тариф, а именно:
    - 18 клиентов, которые работают только на входящих звонках;
    - 105 клиентов, которые работают как на входящих, так и на исходящих звонках.

## Проверка гипотез

Необходимо проверить 2 гипотезы:
1. Цена услуг различается на тарифных планах А и В;
2. Средняя длительность звонка различается на тарифных планах А и В:
    - Сформулировать нулевую и альтернативную гипотезу;
    - Определить какой критерий применить для проверки гипотезы, и почему.

### Цена услуг различается на тарифных планах А и В

**Нулевая гипотеза:** распределение платы по текущему тарифному плану нормально.

**Альтернативная гипотеза:** распределение платы по текущему тарифному плану не нормально.


```python
from scipy import stats as st

client_a = telecom_payment[telecom_payment['Текущий тарифный план'] == 'A']
client_b = telecom_payment[telecom_payment['Текущий тарифный план'] == 'B']
client_c = telecom_payment[telecom_payment['Текущий тарифный план'] == 'C']
```


```python
alpha = 0.05
```


```python
def test(group):
    results = st.shapiro(group['Плата по текущему тарифному плану за период, руб.'])
    p_value = results[1]
    
    print('p-значение: ', p_value)
    
    if p_value < alpha:
        print('Нулевая гипотеза отвергнута.')
    else:
        print('Не получилось отвергнуть нулевую гипотезу.')
```


```python
test(client_a)
```

    p-значение:  3.3004036481543153e-07
    Нулевая гипотеза отвергнута.


Распределение платы для клиентов тарифа A не нормально.


```python
test(client_b)
```

    p-значение:  1.1982552103328992e-11
    Нулевая гипотеза отвергнута.


Распределение платы для клиентов тарифа B не нормально.


```python
test(client_c)
```

    p-значение:  5.982981308733787e-14
    Нулевая гипотеза отвергнута.


Распределение платы для клиентов тарифа C не нормально.

Для снижения вероятности получения ложнопозитивного результата при множественной проверке гипотез внесём поправку, применив метод Бонферрони. 

В связи с тем, что мы будем проводить 3 сравнения, то уровень статистической значимости снизим в 3 раза.


```python
bonferroni = alpha/3
bonferroni
```




    0.016666666666666666



#### Средняя стоимость услуг у клиентов тарифа A и B

**Нулевая гипотеза:** цена услуг на тарифных планах А и В равна.

**Альтернативная гипотеза:** цена услуг на тарифных планах А и В различается.


```python
alpha = bonferroni
```


```python
def group_test(group1, group2):
    results = st.mannwhitneyu(
        group1['Плата по текущему тарифному плану за период, руб.'], 
        group2['Плата по текущему тарифному плану за период, руб.'])

    print('p-значение:', results.pvalue)
    if results.pvalue < alpha:
        print("Отвергаем нулевую гипотезу")
    else:
        print("Не получилось отвергнуть нулевую гипотезу")
```


```python
group_test(client_a, client_b)
```

    p-значение: 2.1870055468771543e-12
    Отвергаем нулевую гипотезу


Цена услуг на тарифных планах А и В различается.

#### Средняя стоимость услуг у клиентов тарифа A и C

**Нулевая гипотеза:** цена услуг на тарифных планах А и C равна.

**Альтернативная гипотеза:** цена услуг на тарифных планах А и C различается.


```python
group_test(client_a, client_c)
```

    p-значение: 3.120626078794628e-13
    Отвергаем нулевую гипотезу


Цена услуг на тарифных планах А и C различается.

#### Средняя стоимость услуг у клиентов тарифа B и C

**Нулевая гипотеза:** цена услуг на тарифных планах А и C равна.

**Альтернативная гипотеза:** цена услуг на тарифных планах А и C различается.

**Нулевая гипотеза:** Средняя длительность звонка на тарифных планах А и В равна.

**Альтернативная гипотеза:** Средняя длительность звонка на тарифных планах А и В различается.


```python
group_test(client_b, client_c)
```

    p-значение: 3.425974738318748e-15
    Отвергаем нулевую гипотезу


Цена услуг на тарифных планах B и C различается.

### Средняя длительность звонка различается на тарифных планах А и В


```python
average_call_duration = telecom_au[['id клиента', 'Общее количество звонков клиента', 'Общее время разговора клиента, сек.', 'Тарифный план']]
average_call_duration
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id клиента</th>
      <th>Общее количество звонков клиента</th>
      <th>Общее время разговора клиента, сек.</th>
      <th>Тарифный план</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>167626</td>
      <td>68543</td>
      <td>3122180</td>
      <td>A</td>
    </tr>
    <tr>
      <th>1</th>
      <td>168361</td>
      <td>58639</td>
      <td>4109075</td>
      <td>A</td>
    </tr>
    <tr>
      <th>2</th>
      <td>168062</td>
      <td>24547</td>
      <td>610021</td>
      <td>A</td>
    </tr>
    <tr>
      <th>3</th>
      <td>168252</td>
      <td>22375</td>
      <td>1575237</td>
      <td>A</td>
    </tr>
    <tr>
      <th>4</th>
      <td>168187</td>
      <td>21398</td>
      <td>1140608</td>
      <td>A</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>266</th>
      <td>168575</td>
      <td>17</td>
      <td>589</td>
      <td>C</td>
    </tr>
    <tr>
      <th>267</th>
      <td>166726</td>
      <td>17</td>
      <td>480</td>
      <td>C</td>
    </tr>
    <tr>
      <th>268</th>
      <td>168004</td>
      <td>17</td>
      <td>45</td>
      <td>C</td>
    </tr>
    <tr>
      <th>269</th>
      <td>167288</td>
      <td>16</td>
      <td>44</td>
      <td>B</td>
    </tr>
    <tr>
      <th>270</th>
      <td>168110</td>
      <td>16</td>
      <td>1335</td>
      <td>C</td>
    </tr>
  </tbody>
</table>
<p>271 rows × 4 columns</p>
</div>




```python
average_call_duration = average_call_duration.query('`Общее время разговора клиента, сек.` > 0').reset_index()

average_call_duration['Средняя длительность звонка, сек.'] = average_call_duration['Общее время разговора клиента, сек.']/average_call_duration['Общее количество звонков клиента']
average_call_duration['Средняя длительность звонка, сек.'] = round(average_call_duration['Средняя длительность звонка, сек.'], 2)
average_call_duration = average_call_duration.sort_values(by = 'Средняя длительность звонка, сек.', ascending = False)
average_call_duration
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>id клиента</th>
      <th>Общее количество звонков клиента</th>
      <th>Общее время разговора клиента, сек.</th>
      <th>Тарифный план</th>
      <th>Средняя длительность звонка, сек.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>146</th>
      <td>147</td>
      <td>167455</td>
      <td>248</td>
      <td>118018</td>
      <td>C</td>
      <td>475.88</td>
    </tr>
    <tr>
      <th>117</th>
      <td>118</td>
      <td>168315</td>
      <td>416</td>
      <td>112262</td>
      <td>B</td>
      <td>269.86</td>
    </tr>
    <tr>
      <th>211</th>
      <td>213</td>
      <td>167534</td>
      <td>60</td>
      <td>11672</td>
      <td>C</td>
      <td>194.53</td>
    </tr>
    <tr>
      <th>247</th>
      <td>251</td>
      <td>168606</td>
      <td>27</td>
      <td>5101</td>
      <td>C</td>
      <td>188.93</td>
    </tr>
    <tr>
      <th>8</th>
      <td>8</td>
      <td>166658</td>
      <td>12794</td>
      <td>2357306</td>
      <td>B</td>
      <td>184.25</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>147</th>
      <td>148</td>
      <td>168366</td>
      <td>246</td>
      <td>147</td>
      <td>C</td>
      <td>0.60</td>
    </tr>
    <tr>
      <th>175</th>
      <td>176</td>
      <td>168377</td>
      <td>136</td>
      <td>54</td>
      <td>B</td>
      <td>0.40</td>
    </tr>
    <tr>
      <th>257</th>
      <td>262</td>
      <td>167012</td>
      <td>19</td>
      <td>6</td>
      <td>B</td>
      <td>0.32</td>
    </tr>
    <tr>
      <th>201</th>
      <td>202</td>
      <td>166548</td>
      <td>78</td>
      <td>18</td>
      <td>B</td>
      <td>0.23</td>
    </tr>
    <tr>
      <th>212</th>
      <td>215</td>
      <td>166481</td>
      <td>58</td>
      <td>5</td>
      <td>A</td>
      <td>0.09</td>
    </tr>
  </tbody>
</table>
<p>266 rows × 6 columns</p>
</div>



Зададим переменные для средних значений длительности звонков по тарифам.


```python
avg_cd_a = average_call_duration[average_call_duration['Тарифный план'] == 'A']
avg_cd_b = average_call_duration[average_call_duration['Тарифный план'] == 'B']
avg_cd_c = average_call_duration[average_call_duration['Тарифный план'] == 'C']
```

Проверим методом Шапиро-Уилка можно ли считать среднюю длительность звонков нормально распределённой.

**Нулевая гипотеза:** распределение длительности звонка по текущему тарифному плану нормально.

**Альтернативная гипотеза:** распределение длительности звонка по текущему тарифному плану не нормально.


```python
def test(group):
    results = st.shapiro(group['Средняя длительность звонка, сек.'])
    p_value = results[1]
    
    print('p-значение: ', p_value)
    
    if p_value < alpha:
        print('Нулевая гипотеза отвергнута.')
    else:
        print('Не получилось отвергнуть нулевую гипотезу.')
```


```python
test(avg_cd_a)
```

    p-значение:  0.9773451685905457
    Не получилось отвергнуть нулевую гипотезу.


Распределение длительности звонка по тарифу А нормально.


```python
test(avg_cd_b)
```

    p-значение:  5.427187144135814e-09
    Нулевая гипотеза отвергнута.


Распределение длительности звонка по тарифу B не нормально.


```python
test(avg_cd_c)
```

    p-значение:  6.542595245853319e-16
    Нулевая гипотеза отвергнута.


Распределение длительности звонка по тарифу C не нормально.

По аналогии как и с предыдущим подразделов, проверим гипотезу U-критерием Манна-Уитни.

Корректировки уровня значимости изменять не будем.


```python
def group_test(group1, group2):
    results = st.mannwhitneyu(
        group1['Средняя длительность звонка, сек.'], 
        group2['Средняя длительность звонка, сек.'])

    print('p-значение:', results.pvalue)
    if results.pvalue < alpha:
        print("Отвергаем нулевую гипотезу")
    else:
        print("Не получилось отвергнуть нулевую гипотезу")
```

#### Средняя длительность звонка различается на тарифных планах А и В

**Нулевая гипотеза:** средняя длительность звонка на тарифных планах А и В равна.

**Альтернативная гипотеза:** средняя длительность звонка на тарифных планах А и В различается.


```python
group_test(avg_cd_a, avg_cd_b)
```

    p-значение: 0.33146480473213935
    Не получилось отвергнуть нулевую гипотезу


Средняя длительность звонка на тарифных планах А и В равна.

#### Средняя длительность звонка различается на тарифных планах А и C

**Нулевая гипотеза:** средняя длительность звонка на тарифных планах А и C равна.

**Альтернативная гипотеза:** средняя длительность звонка на тарифных планах А и C различается.


```python
group_test(avg_cd_a, avg_cd_c)
```

    p-значение: 0.15284616684805366
    Не получилось отвергнуть нулевую гипотезу


Средняя длительность звонка на тарифных планах А и C равна.

#### Средняя длительность звонка различается на тарифных планах B и C

**Нулевая гипотеза:** средняя длительность звонка на тарифных планах B и C равна.

**Альтернативная гипотеза:** средняя длительность звонка на тарифных планах B и C различается.


```python
group_test(avg_cd_b, avg_cd_c)
```

    p-значение: 0.640081395642508
    Не получилось отвергнуть нулевую гипотезу


Средняя длительность звонка на тарифных планах B и C равна.

### Вывод

По итогам проверок гипотез мы пришли к выводу, что:
- Цена услуг на тарифных планах А и В не равна;
- Средняя длительность звонка на тарифных планах А и В равна.

## Общий вывод

**1. При предварительном анализе датасетов были выявлены следующие моменты:**

В датасете **'telecom_dataset'**:
- Всего в таблице 53 902 строк и 9 колонок;
- В 2-х колонках есть пропуски: 'internal' и 'operator_id';
- Названия колонок не имеют нарушения стилей;
- Колонки 'date', 'internal' и 'operator_id' имеют неверный тип;
- Датасет имеет 4 900 полных дубликатов.

В датасете **'telecom_client'**:

- Всего в таблице 732 строки и 3 колонки;
- В колонках пропусков нет;
- Названия колонок не имеют нарушения стилей;
- Колонка 'date_start' имеет неверный тип;
- Вывод по каждому датасету сформирован. Есть над чем работать и что обрабатывать. Анализ датасетов на наличие "аномалий" выполним во время предобработки.

Данных для проведения исследования было достаточно.

**2. Была проведена предобработка исходных данных перед началом исследовательского анализа, а именно:**

- Заполнены пропуска в колонках 'internal' и 'operator_id' датасета '**telecom_dataset**';
- Изменён тип данных в колонках 'date', 'internal' и 'operator_id' датасета '**telecom_dataset**' и тип данных колонки 'date_start''**telecom_client**';
- Удалены полные дубликаты в датасете '**telecom_dataset**';
- Обработаны "аномалии" в колонках 'calls_count', 'call_duration' и 'total_call_duration' датасета '**telecom_dataset**';
- Датасеты объединены по колонке 'user_id' датасета '**telecom_dataset**';
- Названия колонок переименованы.

Считаю, что данные к исследовательскому анализу были подготовлены.

**3. Был проведён исследовательский анализ по поиску клиентов с неоптимальными тарифами провайдера "Нупозвони". В результате исследовательского анализа выяснил следующее:**

- Наиболее активными клиентами являются 271 компания;
- Входящих звонков 40,92 % от общего количества. Исходящих - 59.08 %. Наблюдаются спады звонков в выходные дни;
- Пропущенных звонков 43,6 % от общего количества. Принятых - 56,4 %. Спады также наблюдаются в выходные;
- Процент звонков внутри сети 11,92 %. Процент звонков с клиентами других операторов - 88,08 %;
- Заметный рост количества звонков к концу расчётного периода;
- Регистрация на сервисе распределена равномерно по всему периоду;
- Общее количество звонков (входящие и исходящие) у "лидера" рейтинга - 68543;
- Наибольшее количество операторов у клиента 167626 - 48;
- 214 клиентов совершали и исходящие и входящие звонки. 57 клиентов только принимали звонки;
- Среди 57 клиентов, которые только принимали звонки, есть 18 клиентов, кому можно предложить перейти на более выгодный тариф;
- Наиболее популярный тариф среди клиентов тариф С - 103 клиента. Тариф В имеет - 85 клиентов, тариф А - 26;
- Составлены списки, в которых отображены клиенты, рекомендуемые к переходу на другой тариф, а именно:
    - 18 клиентов, которые работают только на входящих звонках;
    - 105 клиентов, которые работают как на входящих, так и на исходящих звонках.

**4. По итогам проверок гипотез мы пришли к выводу, что:**

- Цена услуг на тарифных планах А и В не равна;
- Средняя длительность звонка на тарифных планах А и В равна.

**5. Сделано общее заключение и составлен вывод.**
